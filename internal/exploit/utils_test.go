package exploit

import (
	"io/ioutil"
	"os"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"

	neopb "neo/lib/genproto/neo"
)

func Test_saveExploit(t *testing.T) {
	f, err := ioutil.TempFile("", "")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err == nil {
			t.Errorf("Exploit file %s was not removed: %v", name, err)
		}
	}(f.Name())
	defer func(f *os.File) {
		if err := f.Close(); err == nil {
			t.Errorf("Exploit file was not closed: %v", err)
		}
	}(f)
	testData := []byte("test")
	if _, err := f.Write(testData); err != nil {
		t.Fatalf("f.WriteString() got unexpected error = %v", err)
	}

	outfile, err := ioutil.TempFile("", "")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	if err := outfile.Close(); err != nil {
		t.Fatalf("Close() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err != nil {
			t.Errorf("Error removing %s: %v", name, err)
		}
	}(outfile.Name())
	cfg := &neopb.ExploitConfiguration{
		Entrypoint: "kek",
		IsArchive:  false,
	}
	entry, err := saveExploit(f, outfile.Name(), cfg)
	if err != nil {
		t.Fatalf("Runner.saveExploit() got unexpected error = %v", err)
	}
	if entry != outfile.Name() {
		t.Fatalf("Runner.saveExploit() invalid entry returned = %v ", entry)
	}
	data, err := ioutil.ReadFile(outfile.Name())
	if err != nil {
		t.Fatalf("ioutil.ReadFile() got unexpected error = %v", err)
	}
	if diff := cmp.Diff(data, testData, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned data mismatch (-want +got):\n%s", diff)
	}
}

func Test_prepareEntry(t *testing.T) {
	f, err := ioutil.TempFile("", "exec")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err != nil {
			t.Errorf("Error removing file %s: %v", name, err)
		}
	}(f.Name())
	if err := f.Close(); err != nil {
		t.Fatalf("Close() got unexpected error = %v", err)
	}
	entry, err := prepareEntry(f.Name())
	if err != nil {
		t.Fatalf("Runner.prepareEntry() got unexpected error = %v", err)
	}
	if !strings.Contains(entry, f.Name()) {
		t.Fatalf("Runner.prepareEntry() should return abs path, got = %v", entry)
	}
	fi, err := os.Stat(entry)
	if err != nil {
		t.Fatalf("os.Stat() got unexpected error = %v", err)
	}
	// Check that file is executable.
	if fi.Mode()&0111 == 0 {
		t.Errorf("Runner.prepareEntry() should make file executable, got = %v", fi.Mode())
	}
}
