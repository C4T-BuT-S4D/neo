package exploit

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"strings"
	"testing"
	"time"

	"neo/pkg/archive"
	"neo/pkg/testutils"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/stretchr/testify/require"

	neopb "neo/lib/genproto/neo"
)

func Test_saveExploit(t *testing.T) {
	f, err := ioutil.TempFile("", "")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err == nil {
			t.Errorf("Exploit file %s was not removed: %v", name, err)
		}
	}(f.Name())
	defer func(f *os.File) {
		if err := f.Close(); err == nil {
			t.Errorf("Exploit file was not closed: %v", err)
		}
	}(f)
	testData := []byte("test")
	if _, err := f.Write(testData); err != nil {
		t.Fatalf("f.WriteString() got unexpected error = %v", err)
	}

	outfile, err := ioutil.TempFile("", "")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	if err := outfile.Close(); err != nil {
		t.Fatalf("Close() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err != nil {
			t.Errorf("Error removing %s: %v", name, err)
		}
	}(outfile.Name())
	cfg := &neopb.ExploitConfiguration{
		Entrypoint: "kek",
		IsArchive:  false,
	}
	entry, err := saveExploit(f, outfile.Name(), cfg)
	if err != nil {
		t.Fatalf("Runner.saveExploit() got unexpected error = %v", err)
	}
	if entry != outfile.Name() {
		t.Fatalf("Runner.saveExploit() invalid entry returned = %v ", entry)
	}
	data, err := ioutil.ReadFile(outfile.Name())
	if err != nil {
		t.Fatalf("ioutil.ReadFile() got unexpected error = %v", err)
	}
	if diff := cmp.Diff(data, testData, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned data mismatch (-want +got):\n%s", diff)
	}
}

func Test_saveExploitArchive(t *testing.T) {
	dir, err := ioutil.TempDir("", "TEMP_TAR")
	if err != nil {
		t.Fatalf("ioutil.TempDir() got unexpected error = %v", err)
	}

	remove := func(name string) {
		if err := os.RemoveAll(name); err != nil {
			t.Errorf("File/Directory %s wasn't removed: %v", name, err)
		}
	}

	defer remove(dir)

	writeFile := func(name string, content []byte) error {
		f, err := os.Create(name)
		if err != nil {
			return fmt.Errorf("os.Create() got unexpected error = %w", err)
		}
		if _, err := f.Write(content); err != nil {
			return fmt.Errorf("f.Write() got unexpected error = %w", err)
		}
		if err := f.Close(); err != nil {
			return fmt.Errorf("f.Close() got unexpected error = %w", err)
		}
		return nil
	}

	exploitFile := "exp.py"
	exploitData := []byte("print(1);")
	if err := writeFile(path.Join(dir, exploitFile), exploitData); err != nil {
		t.Fatalf("Failed to create exploit file: %v", err)
	}

	secondFile := "t.txt"
	secondData := []byte("123")
	if err := writeFile(path.Join(dir, secondFile), secondData); err != nil {
		t.Fatalf("Failed to create additional file: %v", err)
	}

	tarFile, err := ioutil.TempFile("", "ARCHIVE")
	if err != nil {
		t.Fatalf("failed to create tmpfile: %v", err)
	}
	defer remove(tarFile.Name())

	if err := archive.Tar(dir, tarFile); err != nil {
		t.Fatalf("failed to create TarGz archive: %v", err)
	}

	if _, err := tarFile.Seek(0, io.SeekStart); err != nil {
		t.Fatalf("failed to seek tar file: %v", err)
	}

	outDir, err := ioutil.TempDir("", "TEMP_UNTAR")
	if err != nil {
		t.Fatalf("ioutil.TempDir() got unexpected error = %v", err)
	}

	defer remove(outDir)

	cfg := &neopb.ExploitConfiguration{
		Entrypoint: exploitFile,
		IsArchive:  true,
	}

	entry, err := saveExploit(tarFile, outDir, cfg)
	if err != nil {
		t.Fatalf("Runner.saveExploit() got unexpected error = %v", err)
	}

	entryDir, entryPath := path.Split(entry)
	entryDir = path.Clean(entryDir)

	if entryDir != outDir {
		t.Fatalf("Runner.saveExploit() invalid entry (%v) dir returned = %v, want = %v ", entry, entryDir, outDir)
	}

	if entryPath != cfg.Entrypoint {
		t.Fatalf("Runner.saveExploit() invalid entry path returned = %v, want = %v ", entryDir, cfg.Entrypoint)
	}

	entryContent, err := ioutil.ReadFile(entry)
	if err != nil {
		t.Fatalf("failed to read entrypoint untared file: %v", err)
	}

	if diff := cmp.Diff(exploitData, entryContent, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned entrypoint data mismatch (-want +got):\n%s", diff)
	}

	additionalContent, err := ioutil.ReadFile(path.Join(entryDir, secondFile))
	if err != nil {
		t.Fatalf("failed to read additional content untared file: %v", err)
	}

	if diff := cmp.Diff(secondData, additionalContent, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned additional data mismatch (-want +got):\n%s", diff)
	}
}

func Test_prepareEntry(t *testing.T) {
	f, err := ioutil.TempFile("", "exec")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err != nil {
			t.Errorf("Error removing file %s: %v", name, err)
		}
	}(f.Name())
	if err := f.Close(); err != nil {
		t.Fatalf("Close() got unexpected error = %v", err)
	}
	entry, err := prepareEntry(f.Name())
	if err != nil {
		t.Fatalf("Runner.prepareEntry() got unexpected error = %v", err)
	}
	if !strings.Contains(entry, f.Name()) {
		t.Fatalf("Runner.prepareEntry() should return abs path, got = %v", entry)
	}
	fi, err := os.Stat(entry)
	if err != nil {
		t.Fatalf("os.Stat() got unexpected error = %v", err)
	}
	// Check that file is executable.
	if fi.Mode()&0111 == 0 {
		t.Errorf("Runner.prepareEntry() should make file executable, got = %v", fi.Mode())
	}
}

func Test_submitResults(t *testing.T) {
	tests := []struct {
		name        string
		ctx         context.Context
		sendResults []Result
		wantResults []Result
		wantRequest bool
		wantErr     error
	}{
		{
			"simple",
			context.Background(),
			[]Result{
				{
					"AAAAA=",
					"exploit",
					"team",
				},
			},
			[]Result{
				{
					"AAAAA=",
					"[neo] exploit",
					"team",
				},
			},
			true,
			nil,
		},
		{
			"cancelled context",
			testutils.CanceledContext(),
			[]Result{
				{
					"AAAAA=",
					"exploit",
					"team",
				},
			},
			nil,
			false,
			context.Canceled,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := testutils.NewCheckedTestServer(t, func(t *testing.T, r *http.Request) {
				t.Helper()
				t.Log("checker called")
				defer t.Log("checker finished")

				require.True(t, tt.wantRequest, "Unexpected request was made")

				auth := r.Header.Get("Authorization")
				token := r.Header.Get("X-Token")
				contentType := r.Header.Get("Content-Type")
				require.Equal(t, "1234", auth, "Invalid auth header %v", auth)
				require.Equal(t, auth, token, "Invalid X-Token header %v", token)
				require.Equal(t, "application/json", contentType, "Invalid content type %v", contentType)

				var results []Result
				err := json.NewDecoder(r.Body).Decode(&results)
				require.NoError(t, err, "Could not json-decode request body: %v", err)

				t.Logf("checker received results: %v", results)

				diff := cmp.Diff(results, tt.wantResults)
				require.Equal(t, "", diff, "Invalid results returned: %v", diff)
			})
			defer s.Close()

			if err := submitResults(tt.ctx, s.URL, "1234", tt.sendResults); !errors.Is(err, tt.wantErr) {
				t.Errorf("submitResults() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_retryLoop(t *testing.T) {
	tests := []struct {
		name      string
		retries   int
		doRetries int
		returnErr error
		lastErr   error
		wantErr   error
	}{
		{
			"simple",
			1,
			1,
			ErrFinishedUnexpectedly,
			nil,
			nil,
		},
		{
			"endless retries",
			-1,
			100,
			ErrFinishedUnexpectedly,
			nil,
			nil,
		},
		{
			"return last error",
			1,
			5,
			io.EOF,
			nil,
			io.EOF,
		},
		{
			"context cancelled",
			5,
			3,
			ErrFinishedUnexpectedly,
			context.Canceled,
			context.Canceled,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cnt := 0
			f := func(context.Context) error {
				cnt += 1
				if cnt < tt.doRetries {
					return tt.returnErr
				}
				return tt.lastErr
			}
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			if err := retryLoop(ctx, "test", tt.retries, time.Millisecond, f); !errors.Is(err, tt.wantErr) {
				t.Errorf("retryLoop() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.retries != -1 && tt.doRetries > tt.retries {
				if cnt != tt.retries {
					t.Errorf("retryLoop() invalid number of retries: got %d, want %d", cnt, tt.retries)
				}
			} else if cnt != tt.doRetries {
				t.Errorf("retryLoop() invalid number of retries: got %d, want %d", cnt, tt.doRetries)
			}
		})
	}
}
