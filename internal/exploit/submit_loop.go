package exploit

import (
	"context"
	"fmt"
	"time"

	"neo/internal/queue"

	"neo/internal/config"

	"github.com/sirupsen/logrus"
)

type submitLoop struct {
	q        queue.Queue
	maxJobs  int
	done     chan struct{}
	finished chan struct{}
	configs  chan *config.Config
	cfg      *config.Config
	factory  queue.Factory
}

func newSubmitLoop(maxJobs int, cfg *config.Config, factory queue.Factory) *submitLoop {
	return &submitLoop{
		q:        factory(maxJobs),
		maxJobs:  maxJobs,
		done:     make(chan struct{}),
		finished: make(chan struct{}),
		configs:  make(chan *config.Config),
		cfg:      cfg,
		factory:  factory,
	}
}

func (l *submitLoop) Run(ctx context.Context) {
	defer close(l.finished)
	defer logrus.Info("Submit queue stopped")

	l.q.Start(ctx)
	defer l.q.Stop()

	t := time.NewTicker(l.cfg.SubmitEvery)
	defer t.Stop()

	var results []Result
	queueCache := make(map[string]bool)

	flush := func() {
		if len(results) == 0 {
			return
		}
		logrus.Infof("Submitting %d flags", len(results))
		logrus.Debugf("Flags: %+v", results)
		if err := submitResults(ctx, l.cfg.FarmURL, l.cfg.FarmPassword, results); err != nil {
			logrus.Errorf("Failed to submit flags to farm: %v", err)
		} else {
			logrus.Infof("Sent %d flags to the farm", len(results))
			results = make([]Result, 0)
		}
	}
	defer flush()
	defer logrus.Info("Shutting down submit queue")

	for {
		select {
		case res, ok := <-l.q.Results():
			if !ok {
				logrus.Warningf("simpleQueue finished unexpectedly, restarting")
				l.q = l.factory(l.maxJobs)
				l.q.Start(ctx)
				break
			}

			for _, match := range l.cfg.FlagRegexp.FindAll(res.Out, -1) {
				flag := string(match)
				if queueCache[flag] {
					continue
				}
				results = append(results, Result{
					Flag:    flag,
					Exploit: res.Name,
					Team:    res.Team,
				})
				queueCache[flag] = true
			}
		case cfg := <-l.configs:
			if l.cfg.SubmitEvery != cfg.SubmitEvery {
				t.Reset(cfg.SubmitEvery)
			}
			l.cfg = cfg
		case <-t.C:
			flush()
		case <-l.done:
			return
		case <-ctx.Done():
			return
		}
	}
}

func (l *submitLoop) Add(t queue.Task) error {
	if err := l.q.Add(t); err != nil {
		return fmt.Errorf("adding to queue: %w", err)
	}
	return nil
}

func (l *submitLoop) Stop() {
	close(l.done)
	<-l.finished
}

func (l *submitLoop) UpdateConfig(ctx context.Context, cfg *config.Config) {
	select {
	case l.configs <- cfg:
	case <-ctx.Done():
	}
}
