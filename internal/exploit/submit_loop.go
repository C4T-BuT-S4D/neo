package exploit

import (
	"context"
	"fmt"
	"sync"
	"time"

	"neo/internal/queue"

	"neo/internal/config"

	"github.com/sirupsen/logrus"
)

type submitLoop struct {
	q       queue.Queue
	maxJobs int
	cfg     *config.Config
	factory queue.Factory

	logger *logrus.Entry
}

func newSubmitLoop(maxJobs int, cfg *config.Config, factory queue.Factory) *submitLoop {
	q := factory(maxJobs)
	return &submitLoop{
		q:       q,
		maxJobs: maxJobs,
		cfg:     cfg,
		factory: factory,

		logger: logrus.WithFields(logrus.Fields{
			"component": "submit_loop",
			"queue":     q.String(),
		}),
	}
}

// Start is synchronous.
// It will block until the context is cancelled.
func (l *submitLoop) Start(ctx context.Context) {
	l.logger.Info("Starting")
	defer l.logger.Info("Stopped")

	var (
		queueWG     sync.WaitGroup
		queueCtx    context.Context
		queueCancel context.CancelFunc
	)
	startQueue := func() {
		l.logger.Info("Starting queue")
		queueWG.Add(1)
		queueCtx, queueCancel = context.WithCancel(ctx)
		go func() {
			defer queueWG.Done()
			l.q.Start(queueCtx)
			l.logger.Info("Queue finished")
		}()
	}
	startQueue()

	stopQueue := func() {
		l.logger.Info("Stopping queue")
		queueCancel()
		l.logger.Info("Waiting for queue to stop")
		queueWG.Wait()
	}
	defer stopQueue()

	t := time.NewTicker(l.cfg.SubmitEvery)
	defer t.Stop()

	var results []Result
	flush := func() {
		if len(results) == 0 {
			return
		}
		logrus.Infof("Submitting %d flags", len(results))
		logrus.Debugf("Flags: %+v", results)
		if err := submitResults(ctx, l.cfg.FarmURL, l.cfg.FarmPassword, results); err != nil {
			l.logger.Errorf("Failed to submit %d flags to farm: %v", len(results), err)
		} else {
			l.logger.Infof("Sent %d flags to the farm", len(results))
			results = make([]Result, 0)
		}
	}
	defer func() {
		l.logger.Info("Running final flush")
		flush()
	}()

	queueCache := make(map[string]struct{})
	for {
		select {
		case res, ok := <-l.q.Results():
			if !ok {
				l.logger.Warningf("Queue finished unexpectedly, restarting")
				stopQueue()
				l.q = l.factory(l.maxJobs)
				startQueue()
				break
			}

			for _, match := range l.cfg.FlagRegexp.FindAll(res.Out, -1) {
				flag := string(match)
				if _, ok := queueCache[flag]; ok {
					continue
				}
				results = append(results, Result{
					Flag:    flag,
					Exploit: res.Name,
					Team:    res.Team,
				})
				queueCache[flag] = struct{}{}
			}
		case <-t.C:
			flush()
		case <-ctx.Done():
			return
		}
	}
}

func (l *submitLoop) Add(t *queue.Task) error {
	if err := l.q.Add(t); err != nil {
		return fmt.Errorf("adding to queue: %w", err)
	}
	return nil
}
