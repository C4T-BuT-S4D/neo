package exploit

import (
	"sync"
	"time"

	epb "github.com/c4t-but-s4d/neo/proto/go/exploits"
)

func NewCache() *Cache {
	return &Cache{
		states: make(map[string]*State),
		m:      sync.RWMutex{},
	}
}

// Cache represents the client local in-memory executable cache.
// Cache is NOT persistent now, so any client restart will cause a re-download of the all exploits.
type Cache struct {
	states map[string]*State
	m      sync.RWMutex
}

func (c *Cache) Exploits() (res []*State) {
	c.m.RLock()
	defer c.m.RUnlock()

	for _, v := range c.states {
		res = append(res, v)
	}
	return
}

func (c *Cache) Exploit(id string) (res *State, ok bool) {
	c.m.RLock()
	defer c.m.RUnlock()
	res, ok = c.states[id]
	return
}

func (c *Cache) Diff(exs []*epb.ExploitState) []*epb.ExploitState {
	c.m.RLock()
	defer c.m.RUnlock()

	var diff []*epb.ExploitState
	for _, ex := range exs {
		state, exists := c.states[ex.ExploitId]
		if !exists {
			diff = append(diff, ex)
			continue
		}
		if state.Version != ex.Version {
			diff = append(diff, ex)
		}
	}
	return diff
}

func (c *Cache) Update(exs []*State) {
	c.m.Lock()
	defer c.m.Unlock()
	for _, ex := range exs {
		c.states[ex.ID] = ex
	}
}

func (c *Cache) UpdateLastRun(exploitID string, t time.Time) {
	c.m.Lock()
	defer c.m.Unlock()
	if ex, ok := c.states[exploitID]; ok {
		ex.LastRun = t
	}
}
