package exploit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"time"

	"neo/internal/client"
	"neo/internal/config"
	"neo/pkg/archive"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/sirupsen/logrus"

	neopb "neo/lib/genproto/neo"
)

const (
	// TODO(jnovikov): Change this to config parameter.
	submitEvery = time.Second * 2
)

func NewRunner(maxJobs int, dir string, c *client.Client) *Runner {
	return &Runner{
		dir:        dir,
		cache:      NewCache(),
		queue:      NewQueue(maxJobs),
		teams:      nil,
		cfg:        &config.Config{},
		client:     c,
		maxJobs:    maxJobs,
		m:          sync.RWMutex{},
		pingTicker: nil,
		runTicker:  nil,
	}
}

type Runner struct {
	cache      *Cache
	queue      *Queue
	teams      map[string]string
	dir        string
	cfg        *config.Config
	client     *client.Client
	maxJobs    int
	m          sync.RWMutex
	pingTicker *time.Ticker
	runTicker  *time.Ticker
}

func (r *Runner) Run(ctx context.Context) error {
	state, err := r.client.Ping(ctx, neopb.PingRequest_HEARTBEAT)
	if err != nil {
		return fmt.Errorf("failed to get inital server state: %w", err)
	}
	cfg, err := config.FromProto(state.GetConfig())
	if err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}
	r.printGreeting()
	r.updateConfig(cfg)
	r.updateExploits(ctx, state.GetExploits())
	r.updateTeams(state.GetClientTeamMap())
	defer r.pingTicker.Stop()
	go r.queue.Run(ctx)
	go r.exploitLoop(ctx)
	go r.submitLoop(ctx)
	r.pingLoop(ctx)

	logrus.Info("Run is finishing, sending the leave ping")
	leaveCtx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	if _, err := r.client.Ping(leaveCtx, neopb.PingRequest_LEAVE); err != nil {
		return fmt.Errorf("failed to send leave ping: %w", err)
	}

	return nil
}

func (r *Runner) pingLoop(ctx context.Context) {
	for {
		select {
		case <-r.pingTicker.C:
			resp, err := r.client.Ping(ctx, neopb.PingRequest_HEARTBEAT)
			if err != nil {
				logrus.Errorf("failed to ping server: %v", err)
				continue
			}
			cfg, err := config.FromProto(resp.GetConfig())
			if err != nil {
				logrus.Errorf("failed to parse config: %v", err)
			}
			r.updateConfig(cfg)
			r.updateExploits(ctx, resp.GetExploits())
			// If updated.
			if r.updateTeams(resp.GetClientTeamMap()) {
				// Restart the queue: will kill all the existing exploits and clear the queue.
				r.restartQueue(ctx)
			}
		case <-ctx.Done():
			return
		}
	}
}

func (r *Runner) exploitLoop(ctx context.Context) {
	for {
		select {
		case <-r.runTicker.C:
			r.m.RLock()
			exs := r.cache.Exploits()
			for _, ex := range exs {
				for id, ip := range r.teams {
					t := NewTask(ex, id, ip, r.cfg.Timeout)
					logrus.Infof("Adding task: %+v", t)
					if err := r.queue.Add(t); err != nil {
						logrus.Errorf("Failed to add %v to queue: %v", t, err)
					}
				}
			}
			r.m.RUnlock()
		case <-ctx.Done():
			return
		}
	}
}

func (r *Runner) submitLoop(ctx context.Context) {
	t := time.NewTicker(submitEvery)
	defer t.Stop()

	var results []Result

	flush := func() {
		if len(results) == 0 {
			return
		}
		logrus.Infof("Going to submit flags: %+v", results)
		if err := r.farmSubmit(results); err != nil {
			logrus.Errorf("Failed to submit flags to farm: %v", err)
		} else {
			logrus.Infof("%d flags were submitted to farm", len(results))
			results = make([]Result, 0)
		}
	}
	defer flush()

	for {
		select {
		case <-ctx.Done():
			return
		case res, ok := <-r.queue.Output:
			// If the channel is closed, we need to flush the results and stop the submitLoop.
			if !ok {
				return
			}
			for _, match := range r.cfg.FlagRegexp.FindAll(res.Out, -1) {
				results = append(results, Result{
					Flag:    string(match),
					Exploit: res.Name,
					Team:    res.Team,
				})
			}
		case <-t.C:
			flush()
		}
	}
}

func (r *Runner) restartQueue(ctx context.Context) {
	r.queue.Stop()
	r.m.Lock()
	defer r.m.Unlock()
	r.queue = NewQueue(r.maxJobs)
	go r.queue.Run(ctx)
	// Calling the r.queue.Stop() will also stop the submit loop. So need to restart it.
	go r.submitLoop(ctx)
}

func (r *Runner) updateTeams(buckets map[string]*neopb.TeamBucket) bool {
	cid := r.client.ID
	ipbuck, ok := buckets[cid]
	if !ok {
		logrus.Errorf("Failed to find IPs in state for client: %s", cid)
		return false
	}
	teams := ipbuck.GetTeams()
	r.m.Lock()
	defer r.m.Unlock()
	if diff := cmp.Diff(r.teams, teams, cmpopts.EquateEmpty()); diff != "" {
		r.teams = teams
		return true
	}
	return false
}

func (r *Runner) updateConfig(new *config.Config) {
	r.m.Lock()
	defer r.m.Unlock()
	oldCfg := *r.cfg
	r.cfg = new
	if r.cfg.PingEvery != oldCfg.PingEvery {
		if r.pingTicker != nil {
			r.pingTicker.Stop()
		}
		r.pingTicker = time.NewTicker(r.cfg.PingEvery)
	}
	if r.cfg.RunEvery != oldCfg.RunEvery {
		if r.runTicker != nil {
			r.runTicker.Stop()
		}
		r.runTicker = time.NewTicker(r.cfg.RunEvery)
	}
}

func (r *Runner) updateExploits(ctx context.Context, exs []*neopb.ExploitState) {
	diff := r.cache.Diff(exs)
	if len(diff) > 0 {
		logrus.Infof("Got %d updated exploits: %v", len(diff), diff)
	}

	var states []State
	for _, ex := range diff {
		st, err := r.updateExploit(ctx, ex)
		if err != nil {
			logrus.Errorf("Failed to update/download executable(%s:%d): %v", ex.GetExploitId(), ex.GetVersion(), err)
			continue
		}
		states = append(states, *st)
	}
	r.cache.Update(states)
}

func (r *Runner) updateExploit(ctx context.Context, state *neopb.ExploitState) (*State, error) {
	// Download the executable configuration.
	cfg, err := r.client.ExploitConfig(ctx, state.GetExploitId())
	if err != nil {
		return nil, err
	}

	// Create temp file for download.
	f, err := ioutil.TempFile(r.dir, "DOWNLOAD")
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = f.Close()
		_ = os.Remove(f.Name())
	}()

	// Download the executable to temp file.
	if err := r.client.DownloadFile(ctx, state.GetFile(), f); err != nil {
		return nil, err
	}
	// Seek to beginning to use file as an io.Reader.
	if _, err := f.Seek(0, io.SeekStart); err != nil {
		return nil, err
	}

	oPath := filepath.Join(r.dir, fmt.Sprintf("%s_%d", state.GetExploitId(), state.GetVersion()))
	entryPath := oPath

	if entryPath, err = r.saveExploit(f, oPath, cfg); err != nil {
		return nil, err
	}
	logrus.Infof("path = %s, entry = %s", oPath, entryPath)

	if entryPath, err = r.prepareEntry(entryPath); err != nil {
		return nil, err
	}

	res := &State{
		ID:      state.GetExploitId(),
		Version: state.GetVersion(),
		Dir:     "",
		Path:    entryPath,
	}
	if cfg.GetIsArchive() {
		res.Dir = oPath
	}
	return res, nil
}

func (r *Runner) saveExploit(f *os.File, outPath string, cfg *neopb.ExploitConfiguration) (string, error) {
	if cfg.GetIsArchive() {
		if err := archive.Untar(outPath, f); err != nil {
			return "", err
		}
		return filepath.Join(outPath, cfg.GetEntrypoint()), nil
	}

	if err := f.Close(); err != nil {
		return "", err
	}
	if err := os.Rename(f.Name(), outPath); err != nil {
		return "", err
	}
	return outPath, nil
}

func (r *Runner) farmSubmit(res []Result) error {
	// For destructive farm only now.
	url := r.cfg.FarmUrl + "/api/post_flags"

	for i := range res {
		res[i].Exploit = "[neo] " + res[i].Exploit
	}

	data, err := json.Marshal(res)
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", url, bytes.NewReader(data))
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", r.cfg.FarmPassword)
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			logrus.Errorf("Error closing submission response body: %v", err)
		}
	}()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to submit flags to farm with code = %d", resp.StatusCode)
	}
	return err
}

func (r *Runner) prepareEntry(path string) (string, error) {
	absPath, err := filepath.Abs(path)
	if err != nil {
		return "", err
	}
	return absPath, os.Chmod(absPath, 0755)
}

func (r *Runner) printGreeting() {
	fmt.Println(`       _                                                               
   ___| |__  ___   _ __   ___  ___    _ __ _   _ _ __  _ __   ___ _ __ 
  / __| '_ \/ __| | '_ \ / _ \/ _ \  | '__| | | | '_ \| '_ \ / _ \ '__|
 | (__| |_) \__ \ | | | |  __/ (_) | | |  | |_| | | | | | | |  __/ |   
  \___|_.__/|___/ |_| |_|\___|\___/  |_|   \__,_|_| |_|_| |_|\___|_|   
                                                                       `)
}
