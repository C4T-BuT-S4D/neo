package exploit

import (
	"bytes"
	"context"
	"errors"
	"os/exec"

	"github.com/sirupsen/logrus"
)

const maxBufferSize = 10000

var (
	QueueFull = errors.New("queue channel is full")
)

type Queue struct {
	Output chan *Output
	c      chan Task
	done   chan struct{}
	sem    chan struct{}
}

func NewQueue(maxJobs int) *Queue {
	return &Queue{
		Output: make(chan *Output, maxBufferSize),
		c:      make(chan Task, maxBufferSize),
		done:   make(chan struct{}),
		sem:    make(chan struct{}, maxJobs),
	}
}

func (eq *Queue) Add(et Task) error {
	select {
	case eq.c <- et:
		return nil
	default:
		return QueueFull
	}
}

func (eq *Queue) runExploit(ctx context.Context, et Task) ([]byte, error) {
	ctx, cancel := context.WithTimeout(ctx, et.timeout)
	defer cancel()

	logrus.Infof("Going to run: %s %s", et.executable, et.ip)
	cmd := exec.CommandContext(ctx, et.executable, et.ip)
	if et.dir != "" {
		cmd.Dir = et.dir
	}

	res := new(bytes.Buffer)
	errC := make(chan error, 1)
	go func() {
		cmd.Stdout = res
		cmd.Stderr = res
		errC <- cmd.Run()
	}()
	select {
	case <-eq.done:
		cancel()
		<-errC
		return res.Bytes(), context.Canceled
	case <-ctx.Done():
		<-errC
		return res.Bytes(), context.Canceled
	case err := <-errC:
		return res.Bytes(), err
	}
}

func (eq *Queue) Stop() {
	close(eq.done)
}

func (eq *Queue) Run(ctx context.Context) {
	defer close(eq.Output)
	for {
		select {
		case <-ctx.Done():
			return
		case <-eq.done:
			return
		case job := <-eq.c:
			// Acquire semaphore.
			eq.sem <- struct{}{}
			// Run the executable code.
			res, err := eq.runExploit(ctx, job)
			// Release semaphore.
			<-eq.sem
			if err != nil {
				logrus.Errorf("Failed to run %v: %v. Output: %s", job, err, res)
			} else {
				logrus.Infof("Successfully run: %v", job)
			}
			eq.Output <- &Output{
				Name: job.name,
				Out:  res,
				Team: job.ip,
			}
		}
	}
}
