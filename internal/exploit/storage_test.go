package exploit

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/stretchr/testify/require"

	"github.com/c4t-but-s4d/neo/v2/pkg/archive"
	epb "github.com/c4t-but-s4d/neo/v2/pkg/proto/exploits"
)

func mockStorage() (*Storage, func() error) {
	name, err := os.MkdirTemp("", "testStorage")
	if err != nil {
		panic(err)
	}

	return NewStorage(NewCache(), name, nil), func() error {
		if err != nil {
			return fmt.Errorf("remove exploit storage: %w", os.RemoveAll(name))
		}
		return nil
	}
}

func TestStorage_Exploit(t *testing.T) {
	st, cleanup := mockStorage()
	defer func() {
		require.NoError(t, cleanup())
	}()
	st.cache.Update([]*State{
		{ID: "1", Version: 1},
	})
	res, ok := st.Exploit("1")
	require.True(t, ok)
	require.EqualValues(t, 1, res.Version)
}

func Test_saveExploit(t *testing.T) {
	f, err := os.CreateTemp("", "")
	require.NoError(t, err)
	defer func(f *os.File) {
		require.Error(t, f.Close())
		require.True(t, os.IsNotExist(os.Remove(f.Name())))
	}(f)
	testData := []byte("test")
	_, err = f.Write(testData)
	require.NoError(t, err)

	outfile, err := os.CreateTemp("", "")
	require.NoError(t, err)
	require.NoError(t, outfile.Close())
	defer func() {
		require.NoError(t, os.Remove(outfile.Name()))
	}()
	cfg := &epb.ExploitConfiguration{
		Entrypoint: "kek",
		IsArchive:  false,
	}
	entry, err := saveExploit(f, outfile.Name(), cfg)
	require.NoError(t, err)
	require.Equal(t, outfile.Name(), entry)

	data, err := os.ReadFile(outfile.Name())
	require.NoError(t, err)

	if diff := cmp.Diff(data, testData, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned data mismatch (-want +got):\n%s", diff)
	}
}

func Test_saveExploitArchive(t *testing.T) {
	dir, err := os.MkdirTemp("", "TEMP_TAR")
	require.NoError(t, err)

	remove := func(name string) {
		require.NoError(t, os.RemoveAll(name))
	}

	defer remove(dir)

	writeFile := func(name string, content []byte) error {
		f, err := os.Create(name)
		if err != nil {
			return fmt.Errorf("os.Create() got unexpected error = %w", err)
		}
		if _, err := f.Write(content); err != nil {
			return fmt.Errorf("f.Write() got unexpected error = %w", err)
		}
		if err := f.Close(); err != nil {
			return fmt.Errorf("f.Close() got unexpected error = %w", err)
		}
		return nil
	}

	exploitFile := "exp.py"
	exploitData := []byte("print(1);")
	require.NoError(t, writeFile(path.Join(dir, exploitFile), exploitData))

	secondFile := "t.txt"
	secondData := []byte("123")
	require.NoError(t, writeFile(path.Join(dir, secondFile), secondData))

	tarFile, err := os.CreateTemp("", "ARCHIVE")
	require.NoError(t, err)
	defer remove(tarFile.Name())

	require.NoError(t, archive.Tar(dir, tarFile))

	_, err = tarFile.Seek(0, io.SeekStart)
	require.NoError(t, err)

	outDir, err := os.MkdirTemp("", "TEMP_UNTAR")
	require.NoError(t, err)

	defer remove(outDir)

	cfg := &epb.ExploitConfiguration{
		Entrypoint: exploitFile,
		IsArchive:  true,
	}

	entry, err := saveExploit(tarFile, outDir, cfg)
	require.NoError(t, err)

	entryDir, entryPath := path.Split(entry)
	entryDir = path.Clean(entryDir)

	require.Equal(t, outDir, entryDir)
	require.Equal(t, cfg.Entrypoint, entryPath)

	entryContent, err := os.ReadFile(entry)
	require.NoError(t, err)

	if diff := cmp.Diff(exploitData, entryContent, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned entrypoint data mismatch (-want +got):\n%s", diff)
	}

	additionalContent, err := os.ReadFile(path.Join(entryDir, secondFile))
	require.NoError(t, err)

	if diff := cmp.Diff(secondData, additionalContent, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned additional data mismatch (-want +got):\n%s", diff)
	}
}

func Test_prepareEntry(t *testing.T) {
	f, err := os.CreateTemp("", "exec")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(f.Name()))
	}()
	require.NoError(t, f.Close())

	entry, err := prepareEntry(f.Name())
	require.NoError(t, err)
	require.True(t, strings.Contains(entry, f.Name()))

	fi, err := os.Stat(entry)
	require.NoError(t, err)
	// Check that file is executable.
	require.NotZero(t, fi.Mode()&0111)
}

func TestStorage_Scale(t *testing.T) {
	st, cleanup := mockStorage()
	defer func() {
		require.NoError(t, cleanup())
	}()

	// This exploit's timeout should be halved, as teams = 2 * workers.
	st.cache.Update([]*State{
		{
			ID:            "1",
			Version:       1,
			RunEvery:      time.Minute,
			ScaledTimeout: time.Minute,
			Timeout:       time.Minute,
		},
	})
	st.ScaleTimeouts(10, 20, 1)

	res, ok := st.Exploit("1")
	require.True(t, ok)
	require.EqualValues(t, 1, res.Version)
	require.EqualValues(t, time.Minute, res.RunEvery)
	require.EqualValues(t, 30*time.Second, res.ScaledTimeout)

	// Now it should be doubled, as workers = 2 * teams.
	st.ScaleTimeouts(20, 10, 1)

	res, ok = st.Exploit("1")
	require.True(t, ok)
	require.EqualValues(t, time.Minute, res.RunEvery)
	require.EqualValues(t, 2*time.Minute, res.ScaledTimeout)

	// Add another exploit, expect scale to work proportionally to original timeouts.
	st.cache.Update([]*State{
		{
			ID:            "2",
			Version:       1,
			RunEvery:      time.Minute,
			ScaledTimeout: time.Minute,
			Timeout:       time.Minute,
		},
	})
	st.ScaleTimeouts(20, 10, 1)

	res, ok = st.Exploit("1")
	require.True(t, ok)
	require.EqualValues(t, time.Minute, res.RunEvery)
	require.EqualValues(t, time.Minute, res.ScaledTimeout)

	res, ok = st.Exploit("2")
	require.True(t, ok)
	require.EqualValues(t, time.Minute, res.RunEvery)
	require.EqualValues(t, time.Minute, res.ScaledTimeout)

	// Scale with target = 2, expect exploit timeouts to scale up.
	st.ScaleTimeouts(20, 10, 2)

	res, ok = st.Exploit("1")
	require.True(t, ok)
	require.EqualValues(t, 2*time.Minute, res.ScaledTimeout)

	res, ok = st.Exploit("2")
	require.True(t, ok)
	require.EqualValues(t, 2*time.Minute, res.ScaledTimeout)
}
