package exploit

import (
	"context"
	"os/exec"
	"reflect"
	"testing"
	"time"

	"neo/pkg/testutils"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

func TestQueue_Add(t *testing.T) {
	makeQueue := func(s int) *Queue {
		q := NewQueue(1)
		q.c = make(chan Task, s)
		return q
	}
	for _, tc := range []struct {
		q        *Queue
		t        *Task
		wantTask *Task
		wantErr  error
	}{
		{q: makeQueue(100), t: &Task{executable: "1"}, wantErr: nil},
		{q: makeQueue(1), t: &Task{executable: "1"}, wantErr: nil},
		{q: makeQueue(0), t: &Task{executable: "1"}, wantErr: QueueFull},
	} {
		err := tc.q.Add(*tc.t)
		if err != tc.wantErr {
			t.Errorf("Queue.Add(): got error = %v, want = %v", err, tc.wantErr)
			continue
		}
		if err != nil {
			continue
		}
		if tk := <-tc.q.c; tk.executable != tc.t.executable {
			t.Errorf("Queue.Add(): got unexpected data = %v, want = %v", tk, tc.t)
		}
	}
}

func TestQueue_runExploit(t *testing.T) {
	closedQueue := func() *Queue {
		q := NewQueue(1)
		q.Stop()
		return q
	}
	for _, tc := range []struct {
		q        *Queue
		t        Task
		ctx      context.Context
		wantErr  error
		wantData []byte
	}{
		{
			q:        NewQueue(1),
			t:        Task{name: "echo", executable: "echo", teamId: "id", teamIp: "ip", timeout: time.Second * 5},
			wantErr:  nil,
			wantData: []byte("ip\n"),
			ctx:      context.Background(),
		},
		{
			q:        NewQueue(1),
			t:        Task{name: "bad executable", executable: "notfoundcli", teamId: "id", teamIp: "ip", timeout: time.Second * 5},
			wantErr:  &exec.Error{},
			wantData: nil,
			ctx:      context.Background(),
		},
		{
			q:        NewQueue(1),
			t:        Task{name: "echo", executable: "echo", teamId: "id", teamIp: "ip", timeout: time.Second * 5},
			wantErr:  context.Canceled,
			wantData: nil,
			ctx:      testutils.CanceledContext(),
		},
		{
			q:        NewQueue(1),
			t:        Task{name: "echo", executable: "echo", teamId: "id", teamIp: "ip", timeout: time.Second * 5},
			wantErr:  context.Canceled,
			wantData: nil,
			ctx:      testutils.CanceledContext(),
		},
		{
			q:        NewQueue(1),
			t:        Task{name: "echo", executable: "echo", teamId: "id", teamIp: "ip", timeout: time.Second * 5},
			wantErr:  context.Canceled,
			wantData: nil,
			ctx:      testutils.TimedOutContext(),
		},
		{
			q:        NewQueue(1),
			t:        Task{name: "echo", executable: "echo", teamId: "id", teamIp: "ip", timeout: time.Second * 0},
			wantErr:  context.Canceled,
			wantData: nil,
			ctx:      context.Background(),
		},
		{
			q:        closedQueue(),
			t:        Task{name: "echo", executable: "echo", teamId: "id", teamIp: "ip", timeout: time.Second * 5},
			wantErr:  context.Canceled,
			wantData: nil,
			ctx:      context.Background(),
		},
	} {
		data, err := tc.q.runExploit(tc.ctx, tc.t)
		cmpErr := func(e1, e2 error) bool {
			if e1 == e2 {
				return true
			}
			return reflect.TypeOf(e1) == reflect.TypeOf(e2)
		}
		if !cmpErr(err, tc.wantErr) {
			t.Errorf("Queue.runExploit(): got unexpected err = %v, want = %v", err, tc.wantErr)
		}

		if diff := cmp.Diff(data, tc.wantData, cmpopts.EquateEmpty()); diff != "" {
			t.Errorf("Queue.runExploit() returned data mismatch (-want +got):\n%s", diff)
		}
	}
}

func TestQueue_Run(t *testing.T) {
	q := NewQueue(10)
	task := Task{name: "kek", executable: "echo", dir: "", teamId: "id", teamIp: "ip", timeout: time.Second * 2}
	err := q.Add(task)
	if err != nil {
		t.Errorf("Queue.Add(): got unexpected error = %v", err)
	}

	var out *Output
	ctx, cancel := context.WithCancel(context.Background())
	q.Run(ctx)
	defer q.Stop()
	out = <-q.Output
	cancel()

	if out.Name != task.name {
		t.Errorf("Queue.Run(): got unexpected result name: got = %v, want = %v", out.Name, task.name)
	}
	if out.Team != task.teamId {
		t.Errorf("Queue.Run(): got unexpected result team: got = %v, want = %v", out.Team, task.teamId)
	}
	if string(out.Out) != task.teamIp+"\n" {
		t.Errorf("Queue.Run(): got unexpected result: got = %v, want = %v", out.Out, task.teamIp+"\n")
	}
}
