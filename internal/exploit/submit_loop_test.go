package exploit

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"regexp"
	"sync"
	"testing"
	"time"

	"neo/pkg/tasklogger"
	"neo/pkg/testutils"

	"github.com/google/go-cmp/cmp"
	"go.uber.org/goleak"

	"github.com/stretchr/testify/require"

	"neo/internal/config"
	"neo/internal/queue"
)

var (
	errQueueFull = errors.New("queue is full")
)

type mockQueue struct {
	out     chan *queue.Output
	in      chan queue.Task
	started chan struct{}
}

func newMockQueue() *mockQueue {
	return &mockQueue{started: make(chan struct{})}
}

func (m *mockQueue) Start(context.Context) {
	m.in = make(chan queue.Task, 100)
	m.out = make(chan *queue.Output, 100)
	close(m.started)
}

func (m *mockQueue) Add(task queue.Task) error {
	select {
	case m.in <- task:
		return nil
	default:
		return errQueueFull
	}
}

func (m *mockQueue) Stop() {
	close(m.in)
	close(m.out)
}

func (m *mockQueue) Results() <-chan *queue.Output {
	return m.out
}

func TestMain(m *testing.M) {
	goleak.VerifyTestMain(m)
}

func Test_newSubmitLoop(t *testing.T) {
	q := newMockQueue()
	factory := func(int) queue.Queue {
		return q
	}
	cfg := config.Config{
		FarmURL:      "127.0.0.1",
		FarmPassword: "1234",
	}

	want := submitLoop{
		q:       q,
		maxJobs: 5,
		cfg:     &cfg,
		factory: factory,
	}

	got := newSubmitLoop(5, &cfg, factory)

	if got.maxJobs != want.maxJobs {
		t.Errorf("newSubmitQueue(): invalid max jobs: want %v, got %v", want.maxJobs, got.maxJobs)
	}
	if got.cfg != want.cfg {
		t.Errorf("newSubmitQueue(): invalid cfg: want %v, got %v", want.cfg, got.cfg)
	}
	if got.q != want.q {
		t.Errorf("newSubmitQueue(): invalid queue: want %v, got %v", want.q, got.q)
	}
}

func Test_submitLoop_Add(t *testing.T) {
	q := newMockQueue()
	q.Start(context.Background())
	factory := func(int) queue.Queue {
		return q
	}
	cfg := config.Config{
		FarmURL:      "127.0.0.1",
		FarmPassword: "1234",
	}
	sl := newSubmitLoop(1, &cfg, factory)

	sender := tasklogger.NewSender(nil)
	logger := tasklogger.New("id", 1, "127.0.0.1", sender)
	task := queue.NewTask(
		"id",
		"echo",
		"",
		"12",
		"127.0.0.1",
		nil,
		time.Second*5,
		logger,
	)
	require.NoError(t, sl.Add(task), "Add() returned an unexpected error")

	select {
	case got := <-q.in:
		require.Equal(t, got.String(), task.String(), "invalid task added")
	default:
		t.Errorf("Add(): queue is empty after adding task")
	}
}

func Test_submitLoop_AddFullQueue(t *testing.T) {
	q := mockQueue{}
	factory := func(int) queue.Queue {
		return &q
	}
	cfg := config.Config{
		FarmURL:      "127.0.0.1",
		FarmPassword: "1234",
	}
	sl := newSubmitLoop(1, &cfg, factory)

	sender := tasklogger.NewSender(nil)
	logger := tasklogger.New("id", 1, "127.0.0.1", sender)
	task := queue.NewTask(
		"id",
		"echo",
		"",
		"12",
		"127.0.0.1",
		nil,
		time.Second*5,
		logger,
	)
	require.Error(t, sl.Add(task), "Add() did not return an error")
}

func Test_submitLoop_Run(t *testing.T) {
	q := newMockQueue()
	factory := func(int) queue.Queue {
		return q
	}
	wg := sync.WaitGroup{}

	wantResults := []Result{
		{
			Flag:    "AAAAA=",
			Exploit: "[neo] test",
			Team:    "Team 1",
		},
		{
			Flag:    "BBBBB=",
			Exploit: "[neo] another test",
			Team:    "Team 2",
		},
	}
	outputs := []*queue.Output{
		{
			Name: "test",
			Team: "Team 1",
			Out:  []byte("some large AAAAA= output"),
		},
		{
			Name: "another test",
			Team: "Team 2",
			Out:  []byte("some large BBBBB= output"),
		},
	}

	wg.Add(1) // checker must be called once
	checker := func(t *testing.T, r *http.Request) {
		t.Helper()
		t.Log("checker called")
		defer t.Log("checker finished")
		defer wg.Done()

		auth := r.Header.Get("Authorization")
		token := r.Header.Get("X-Token")
		contentType := r.Header.Get("Content-Type")
		require.Equal(t, "1234", auth, "Invalid auth header %v", auth)
		require.Equal(t, auth, token, "Invalid X-Token header %v", token)
		require.Equal(t, "application/json", contentType, "Invalid content type %v", contentType)

		var results []Result
		err := json.NewDecoder(r.Body).Decode(&results)
		require.NoError(t, err, "Could not json-decode request body: %v", err)

		t.Logf("checker received results: %v", results)

		diff := cmp.Diff(results, wantResults)
		require.Equal(t, "", diff, "Invalid results returned: %v", diff)
	}
	s := testutils.NewCheckedTestServer(t, checker)
	defer s.Close()

	cfg := config.Config{
		FarmURL:      s.URL,
		FarmPassword: "1234",
		FlagRegexp:   regexp.MustCompile("[AB]{5}="),
		SubmitEvery:  time.Second,
	}
	sl := newSubmitLoop(1, &cfg, factory)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	slDone := make(chan struct{})
	go func() {
		defer close(slDone)
		defer t.Logf("Submit loop stopped")
		sl.Run(ctx)
	}()

	// wait for the queue to start
	<-q.started

	wg.Add(1) // outputs must be added
	go func() {
		defer wg.Done()
		for _, out := range outputs {
			t.Logf("received output %v", out)
			q.out <- out
		}
	}()

	done := make(chan struct{})
	go func() {
		defer close(done)
		wg.Wait()
	}()

	// wait for results
	select {
	case <-time.After(cfg.SubmitEvery * 2):
		t.Errorf("Run(): test timed out")
	case <-done:
	}

	done = make(chan struct{})
	go func() {
		defer close(done)
		sl.Stop()
		<-slDone // wait for submit loop to stop
	}()

	// gracefully stop the queue
	select {
	case <-time.After(time.Millisecond * 100):
		t.Errorf("Run(): stop timed out")
	case <-done:
	}
}
