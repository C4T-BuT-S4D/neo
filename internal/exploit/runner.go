package exploit

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"time"

	"neo/internal/client"
	"neo/internal/config"
	"neo/pkg/archive"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/sirupsen/logrus"

	neopb "neo/lib/genproto/neo"
)

func NewRunner(maxJobs int, dir string, c *client.Client) *Runner {
	return &Runner{
		dir:        dir,
		cache:      NewCache(),
		teams:      nil,
		cfg:        &config.Config{},
		client:     c,
		maxJobs:    maxJobs,
		pingTicker: nil,
		runTicker:  nil,
	}
}

type Runner struct {
	cache      *Cache
	teams      map[string]string
	dir        string
	cfg        *config.Config
	client     *client.Client
	maxJobs    int
	pingTicker *time.Ticker
	runTicker  *time.Ticker

	cfgLock   sync.Mutex
	teamsLock sync.RWMutex
}

func (r *Runner) Run(ctx context.Context) error {
	state, err := r.client.Ping(ctx, neopb.PingRequest_HEARTBEAT)
	if err != nil {
		return fmt.Errorf("failed to get initial server state: %w", err)
	}
	cfg, err := config.FromProto(state.GetConfig())
	if err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}
	r.printGreeting()
	r.updateConfig(cfg)
	r.updateExploits(ctx, state.GetExploits())
	r.updateTeams(state.GetClientTeamMap())
	defer r.pingTicker.Stop()
	defer r.runTicker.Stop()

	wg := new(sync.WaitGroup)

	srvCtx, srvCancel := context.WithCancel(ctx)
	defer srvCancel()

	if err := r.listenBroadcast(srvCtx, wg); err != nil {
		return fmt.Errorf("starting broadcast listener: %w", err)
	}
	defer func() {
		logrus.Info("Waiting for broadcast listener to stop")
		wg.Wait()
	}()

	r.eventLoop(ctx)

	logrus.Info("Worker is finishing, sending the leave ping")
	leaveCtx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	if _, err := r.client.Ping(leaveCtx, neopb.PingRequest_LEAVE); err != nil {
		return fmt.Errorf("failed to send leave ping: %w", err)
	}

	logrus.Info("Stopping broadcast listener")
	srvCancel()
	return nil
}

func (r *Runner) eventLoop(ctx context.Context) {
	defer logrus.Info("Ping loop stopped")

	sl := NewSubmitLoop(r.maxJobs, r.cfg)
	go sl.Run(ctx)
	defer sl.Stop()

	// Run exploits immediately.
	r.submitExploits(sl)

	for {
		select {
		case <-r.pingTicker.C:
			resp, err := r.client.Ping(ctx, neopb.PingRequest_HEARTBEAT)
			if err != nil {
				logrus.Errorf("failed to ping server: %v", err)
				continue
			}
			cfg, err := config.FromProto(resp.GetConfig())
			if err != nil {
				logrus.Errorf("failed to parse config: %v", err)
			}
			r.updateConfig(cfg)
			r.updateExploits(ctx, resp.GetExploits())
			// If updated.
			if r.updateTeams(resp.GetClientTeamMap()) {
				// Restart the queue: will kill all the existing exploits and clear the queue.
				logrus.Info("Stopping submit loop")
				sl.Stop()
				logrus.Info("Recreating submit loop")
				sl = NewSubmitLoop(r.maxJobs, r.cfg)
				go sl.Run(ctx)
			}

		case <-r.runTicker.C:
			r.submitExploits(sl)

		case <-ctx.Done():
			return
		}
	}
}

func (r *Runner) submitExploits(sl *submitLoop) {
	exs := r.cache.Exploits()
	r.teamsLock.RLock()
	defer r.teamsLock.RUnlock()
	for _, ex := range exs {
		for id, ip := range r.teams {
			t := NewTask(ex, id, ip, r.cfg.Environ, r.cfg.Timeout)
			logrus.Infof("Adding task: %+v", t)
			if err := sl.Add(t); err != nil {
				logrus.Errorf("Failed to add %v to queue: %v", t, err)
			}
		}
	}
}

func (r *Runner) listenBroadcast(ctx context.Context, wg *sync.WaitGroup) error {
	resp, err := r.client.ListenBroadcasts(ctx)
	if err != nil {
		return fmt.Errorf("making broadcasts listen request: %w", err)
	}
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case cmd, ok := <-resp:
				if !ok {
					logrus.Infof("Broadcast channel was closed, exiting")
					return
				}
				logrus.Infof("Received a command from broadcast: %v", cmd)
				if err := r.handleBroadcastCommand(ctx, cmd); err != nil {
					logrus.Errorf("Error running broadcast command: %v", err)
				}
			case <-ctx.Done():
				return
			}
		}
	}()
	return nil
}

func (r *Runner) handleBroadcastCommand(ctx context.Context, cmd *neopb.Command) error {
	c := exec.CommandContext(ctx, "/bin/bash", "-c", cmd.Command)
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	if err := c.Run(); err != nil {
		return fmt.Errorf("executing command: %w", err)
	}
	return nil
}

func (r *Runner) updateTeams(buckets map[string]*neopb.TeamBucket) bool {
	cid := r.client.ID
	ipbuck, ok := buckets[cid]
	if !ok {
		logrus.Errorf("Failed to find IPs in state for client: %s", cid)
		return false
	}
	teams := ipbuck.GetTeams()

	r.teamsLock.Lock()
	defer r.teamsLock.Unlock()
	if diff := cmp.Diff(r.teams, teams, cmpopts.EquateEmpty()); diff != "" {
		r.teams = teams
		return true
	}
	return false
}

func (r *Runner) updateConfig(cfg *config.Config) {
	r.cfgLock.Lock()
	defer r.cfgLock.Unlock()

	oldCfg := *r.cfg
	r.cfg = cfg
	if r.cfg.PingEvery != oldCfg.PingEvery {
		if r.pingTicker != nil {
			r.pingTicker.Stop()
		}
		r.pingTicker = time.NewTicker(r.cfg.PingEvery)
	}
	if r.cfg.RunEvery != oldCfg.RunEvery {
		if r.runTicker != nil {
			r.runTicker.Stop()
		}
		r.runTicker = time.NewTicker(r.cfg.RunEvery)
	}
}

func (r *Runner) updateExploits(ctx context.Context, exs []*neopb.ExploitState) {
	diff := r.cache.Diff(exs)
	if len(diff) > 0 {
		logrus.Infof("Got %d updated exploits: %v", len(diff), diff)
	}

	states := make([]State, 0, len(diff))
	for _, ex := range diff {
		st, err := r.updateExploit(ctx, ex)
		if err != nil {
			logrus.Errorf("Failed to update/download executable(%s:%d): %v", ex.GetExploitId(), ex.GetVersion(), err)
			continue
		}
		states = append(states, *st)
	}
	r.cache.Update(states)
}

func (r *Runner) updateExploit(ctx context.Context, state *neopb.ExploitState) (*State, error) {
	// Download the executable configuration.
	cfg, err := r.client.ExploitConfig(ctx, state.GetExploitId())
	if err != nil {
		return nil, fmt.Errorf("requesting exploit config: %w", err)
	}

	// Create temp file for download.
	f, err := ioutil.TempFile(r.dir, "DOWNLOAD")
	if err != nil {
		return nil, fmt.Errorf("creating temp file: %w", err)
	}
	defer func() {
		_ = f.Close()
		_ = os.Remove(f.Name())
	}()

	// Download the executable to temp file.
	if err := r.client.DownloadFile(ctx, state.GetFile(), f); err != nil {
		return nil, fmt.Errorf("downloading file: %w", err)
	}
	// Seek to beginning to use file as an io.Reader.
	if _, err := f.Seek(0, io.SeekStart); err != nil {
		return nil, fmt.Errorf("seeking downloaded file: %w", err)
	}

	oPath := filepath.Join(r.dir, fmt.Sprintf("%s_%d", state.GetExploitId(), state.GetVersion()))

	var entryPath string
	if entryPath, err = r.saveExploit(f, oPath, cfg); err != nil {
		return nil, fmt.Errorf("saving exploit: %w", err)
	}
	logrus.Infof("path = %s, entry = %s", oPath, entryPath)

	if entryPath, err = r.prepareEntry(entryPath); err != nil {
		return nil, fmt.Errorf("prepairing entry: %w", err)
	}

	res := &State{
		ID:      state.GetExploitId(),
		Version: state.GetVersion(),
		Dir:     "",
		Path:    entryPath,
	}
	if cfg.GetIsArchive() {
		res.Dir = oPath
	}
	return res, nil
}

func (r *Runner) saveExploit(f *os.File, outPath string, cfg *neopb.ExploitConfiguration) (string, error) {
	if cfg.GetIsArchive() {
		if err := archive.Untar(outPath, f); err != nil {
			return "", fmt.Errorf("unarchiving: %w", err)
		}
		return filepath.Join(outPath, cfg.GetEntrypoint()), nil
	}

	if err := f.Close(); err != nil {
		return "", fmt.Errorf("closing file: %w", err)
	}
	if err := os.Rename(f.Name(), outPath); err != nil {
		return "", fmt.Errorf("renaming file %s to %s: %w", f.Name(), outPath, err)
	}
	return outPath, nil
}

func (r *Runner) prepareEntry(path string) (string, error) {
	absPath, err := filepath.Abs(path)
	if err != nil {
		return "", fmt.Errorf("taking absolute path: %w", err)
	}
	if err := os.Chmod(absPath, 0755); err != nil {
		return "", fmt.Errorf("setting permissions: %w", err)
	}
	return absPath, nil
}

func (r *Runner) printGreeting() {
	fmt.Println(`       _                                                               
   ___| |__  ___   _ __   ___  ___    _ __ _   _ _ __  _ __   ___ _ __ 
  / __| '_ \/ __| | '_ \ / _ \/ _ \  | '__| | | | '_ \| '_ \ / _ \ '__|
 | (__| |_) \__ \ | | | |  __/ (_) | | |  | |_| | | | | | | |  __/ |   
  \___|_.__/|___/ |_| |_|\___|\___/  |_|   \__,_|_| |_|_| |_|\___|_|   
                                                                       `)
}
