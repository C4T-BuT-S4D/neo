package exploit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/c4t-but-s4d/neo/v2/internal/config"
	"github.com/c4t-but-s4d/neo/v2/internal/queue"
)

type submitLoop struct {
	q       queue.Queue
	maxJobs int
	cfg     *config.ExploitsConfig
	metrics *Metrics
	factory queue.Factory

	logger *logrus.Entry
}

func newSubmitLoop(
	maxJobs int,
	cfg *config.ExploitsConfig,
	metrics *Metrics,
	factory queue.Factory,
) *submitLoop {
	return &submitLoop{
		q:       factory.Create(maxJobs),
		maxJobs: maxJobs,
		factory: factory,
		metrics: metrics,
		cfg:     cfg,

		logger: logrus.WithFields(logrus.Fields{
			"component": "submit_loop",
			"queue":     factory.Type(),
		}),
	}
}

// Start is synchronous.
// It will block until the context is cancelled.
func (l *submitLoop) Start(ctx context.Context) {
	l.logger.Info("Starting")
	defer l.logger.Info("Stopped")

	var (
		queueWG     sync.WaitGroup
		queueCtx    context.Context
		queueCancel context.CancelFunc
	)
	startQueue := func() {
		l.logger.Info("Starting queue")
		queueWG.Add(1)
		queueCtx, queueCancel = context.WithCancel(ctx)

		go func() {
			defer queueWG.Done()
			l.q.Start(queueCtx)
			l.logger.Info("Queue finished")
		}()
	}
	startQueue()

	stopQueue := func() {
		l.logger.Info("Stopping queue")
		queueCancel()
		l.logger.Info("Waiting for queue to stop")
		queueWG.Wait()
	}
	defer stopQueue()

	t := time.NewTicker(l.cfg.SubmitEvery)
	defer t.Stop()

	var results []*FullResult
	flush := func() {
		if len(results) == 0 {
			return
		}
		l.logger.Infof("Submitting %d flags", len(results))
		l.logger.Debugf("Flags: %+v", results)
		if err := l.submitResults(ctx, results); err != nil {
			l.logger.Errorf("Failed to submit %d flags to farm: %v", len(results), err)
		} else {
			l.logger.Infof("Sent %d flags to the farm", len(results))

			for _, result := range results {
				l.metrics.FlagsSubmitted.With(result.MetricLabels()).Inc()
			}

			results = results[:0]
		}
	}
	defer func() {
		l.logger.Info("Running final flush")
		flush()
	}()

	queueCache := make(map[string]struct{})
	for {
		select {
		case res, ok := <-l.q.Results():
			if !ok {
				l.logger.Warningf("Queue finished unexpectedly, restarting")
				stopQueue()
				l.q = l.factory.Create(l.maxJobs)
				startQueue()
				break
			}

			for _, match := range l.cfg.FlagRegexp.FindAll(res.Out, -1) {
				flag := string(match)
				if _, ok := queueCache[flag]; ok {
					continue
				}
				results = append(results, NewFullResult(res.Exploit, res.Target, flag))
				queueCache[flag] = struct{}{}
			}
		case <-t.C:
			flush()
			l.metrics.Queue.WithLabelValues(string(l.q.Type())).Set(float64(l.q.Size()))
		case <-ctx.Done():
			return
		}
	}
}

func (l *submitLoop) Add(t *queue.Job) error {
	if err := l.q.Add(t); err != nil {
		return fmt.Errorf("adding to queue: %w", err)
	}
	return nil
}

func (l *submitLoop) submitResults(ctx context.Context, results []*FullResult) error {
	// For destructive farm only now.
	url := l.cfg.FarmURL + "/api/post_flags"

	toSend := make([]*FarmRequest, 0, len(results))
	for _, fullRes := range results {
		toSend = append(toSend, fullRes.FarmRequest())
	}

	data, err := json.Marshal(toSend)
	if err != nil {
		return fmt.Errorf("could not dump results: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(data))
	if err != nil {
		return fmt.Errorf("creating request: %w", err)
	}
	req.Header.Set("Authorization", l.cfg.FarmPassword)
	req.Header.Add("X-Token", l.cfg.FarmPassword)
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("making request: %w", err)
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			l.logger.Errorf("Error closing submission response body: %v", err)
		}
	}()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to submit flags to farm with code = %d", resp.StatusCode)
	}
	return nil
}
