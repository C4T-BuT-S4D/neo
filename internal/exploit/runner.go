package exploit

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"sync"
	"time"

	"neo/internal/client"
	"neo/internal/config"
	"neo/internal/queue"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/sirupsen/logrus"

	neopb "neo/lib/genproto/neo"
)

var (
	ErrFinishedUnexpectedly = errors.New("service finished unexpectedly")
)

func NewRunner(maxJobs int, dir string, c *client.Client) *Runner {
	return &Runner{
		storage:         NewStorage(NewCache(), dir, c),
		cfg:             &config.Config{},
		client:          c,
		maxJobs:         maxJobs,
		singleRuns:      make(chan *neopb.SingleRunRequest),
		endlessRestarts: make(chan struct{}, 1),
		configUpdated:   make(chan struct{}, 1),
	}
}

type Runner struct {
	storage *Storage
	teams   map[string]string
	cfg     *config.Config
	client  *client.Client
	maxJobs int

	teamsLock sync.RWMutex

	singleRuns      chan *neopb.SingleRunRequest
	endlessRestarts chan struct{}
	configUpdated   chan struct{}
}

func (r *Runner) Run(ctx context.Context) error {
	state, err := r.pingHeartbeat(ctx)
	if err != nil {
		return fmt.Errorf("sending heartbeat: %w", err)
	}

	r.printGreeting()
	r.updateTeams(state.GetClientTeamMap())

	wg := new(sync.WaitGroup)

	srvCtx, srvCancel := context.WithCancel(ctx)
	defer srvCancel()

	wg.Add(2)
	go func() {
		defer wg.Done()
		if err := retryLoop(srvCtx, "broadcast", -1, 3*time.Second, r.listenBroadcast); err != nil && !errors.Is(err, context.Canceled) {
			logrus.Errorf("Error running broadcast loop: %v", err)
		}
	}()
	go func() {
		defer wg.Done()
		if err := retryLoop(srvCtx, "single runs", -1, 3*time.Second, r.listenSingleRuns); err != nil && !errors.Is(err, context.Canceled) {
			logrus.Errorf("Error running single runs loop: %v", err)
		}
	}()
	defer func() {
		logrus.Info("Stopping aux services")
		srvCancel()
		logrus.Info("Waiting for aux services to stop")
		wg.Wait()
	}()

	r.eventLoop(ctx)

	logrus.Info("Worker is finishing, sending the leave ping")
	leaveCtx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	if _, err := r.client.Ping(leaveCtx, neopb.PingRequest_LEAVE); err != nil {
		return fmt.Errorf("failed to send leave ping: %w", err)
	}

	return nil
}

func (r *Runner) pingHeartbeat(ctx context.Context) (*neopb.ServerState, error) {
	state, err := r.client.Ping(ctx, neopb.PingRequest_HEARTBEAT)
	if err != nil {
		return nil, fmt.Errorf("sending ping request: %w", err)
	}
	cfg, err := config.FromProto(state.GetConfig())
	if err != nil {
		return nil, fmt.Errorf("parsing config: %w", err)
	}
	r.updateConfig(cfg)
	r.updateExploits(ctx, state.GetExploits())
	return state, nil
}

func (r *Runner) eventLoop(ctx context.Context) {
	defer logrus.Info("Ping loop stopped")

	simpleLoop := newSubmitLoop(r.maxJobs, r.cfg, queue.NewSimpleQueue)
	go simpleLoop.Run(ctx)
	endlessLoop := newSubmitLoop(r.maxJobs, r.cfg, queue.NewEndlessQueue)
	go endlessLoop.Run(ctx)

	defer func() {
		logrus.Info("Stopping submit loops")
		simpleLoop.Stop()
		endlessLoop.Stop()
	}()

	r.scheduleEndlessExploits(endlessLoop)

	runTicker := time.NewTicker(time.Second)
	defer runTicker.Stop()

	pingEvery := r.cfg.PingEvery
	pingTicker := time.NewTicker(pingEvery)

	for {
		select {
		case <-pingTicker.C:
			state, err := r.pingHeartbeat(ctx)
			if err != nil {
				logrus.Errorf("Error sending recurrent heartbeat: %v", err)
			}
			if r.updateTeams(state.GetClientTeamMap()) {
				// Restart the queue: will kill all the existing exploits and clear the queue.
				logrus.Info("Stopping simple submit loop")
				simpleLoop.Stop()
				logrus.Info("Recreating simple submit loop")
				simpleLoop = newSubmitLoop(r.maxJobs, r.cfg, queue.NewSimpleQueue)
				go simpleLoop.Run(ctx)
				r.restartEndless()
			}

		case <-r.endlessRestarts:
			logrus.Info("Stopping endless submit loop")
			endlessLoop.Stop()
			logrus.Info("Recreating endless submit loop")
			endlessLoop = newSubmitLoop(r.maxJobs, r.cfg, queue.NewEndlessQueue)
			go endlessLoop.Run(ctx)
			r.scheduleEndlessExploits(endlessLoop)

		case <-r.configUpdated:
			simpleLoop.UpdateConfig(r.cfg)
			endlessLoop.UpdateConfig(r.cfg)
			if r.cfg.PingEvery != pingEvery {
				pingEvery = r.cfg.PingEvery
				pingTicker.Reset(pingEvery)
			}

		case <-runTicker.C:
			r.scheduleRecurrentExploits(simpleLoop)

		case req := <-r.singleRuns:
			logrus.Infof("Processing single run request %v", req)

			// Update config to guarantee the requested exploit exists locally.
			if _, err := r.pingHeartbeat(ctx); err != nil {
				logrus.Errorf("Error updating config before single run: %v", err)
			}
			r.submitExploit(simpleLoop, req.ExploitId)

		case <-ctx.Done():
			return
		}
	}
}

func (r *Runner) scheduleRecurrentExploits(l *submitLoop) {
	exs := r.cache.Exploits()
	now := time.Now()
	for _, ex := range exs {
		if ex.Disabled || ex.Endless {
			continue
		}
		if ex.LastRun.Add(ex.RunEvery).After(now) {
			continue
		}
		r.submitExploit(l, ex.ID)
	}
}

func (r *Runner) scheduleEndlessExploits(l *submitLoop) {
	exs := r.storage.Exploits()
	for _, ex := range exs {
		if ex.Disabled || !ex.Endless {
			continue
		}
		r.submitExploit(l, ex.ID)
	}
}

func (r *Runner) submitExploit(l *submitLoop, id string) {
	ex, ok := r.storage.Exploit(id)
	if !ok {
		return
	}
	r.teamsLock.RLock()
	defer r.teamsLock.RUnlock()

	tasks := CreateExploitTasks(ex, r.teams, r.cfg.Environ)
	for _, t := range tasks {
		logrus.Infof("Adding task: %+v", t)
		if err := l.Add(t); err != nil {
			logrus.Errorf("Failed to add %v to queue: %v", t, err)
		}
	}

	r.storage.UpdateLastRun(ex.ID, time.Now())
}

func (r *Runner) restartEndless() {
	select {
	case r.endlessRestarts <- struct{}{}:
	default:
	}
}

func (r *Runner) listenBroadcast(ctx context.Context) error {
	resp, err := r.client.ListenBroadcasts(ctx)
	if err != nil {
		return fmt.Errorf("making broadcasts listen request: %w", err)
	}
	for {
		select {
		case cmd, ok := <-resp:
			if !ok {
				logrus.Error("Broadcast channel was closed, exiting")
				return ErrFinishedUnexpectedly
			}
			logrus.Infof("Received a command from broadcast: %v", cmd)
			if err := r.handleBroadcastCommand(ctx, cmd); err != nil {
				logrus.Errorf("Error running broadcast command: %v", err)
			}
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}

func (r *Runner) listenSingleRuns(ctx context.Context) error {
	resp, err := r.client.ListenSingleRuns(ctx)
	if err != nil {
		return fmt.Errorf("making single run listen request: %w", err)
	}
	for {
		select {
		case req, ok := <-resp:
			if !ok {
				logrus.Error("Single run channel was closed, exiting")
				return ErrFinishedUnexpectedly
			}
			logrus.Infof("Received a single run request: %v", req)
			r.singleRuns <- req
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}

func (r *Runner) handleBroadcastCommand(ctx context.Context, cmd *neopb.Command) error {
	c := exec.CommandContext(ctx, "/bin/bash", "-c", cmd.Command)
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	if err := c.Run(); err != nil {
		return fmt.Errorf("executing command: %w", err)
	}
	return nil
}

func (r *Runner) updateTeams(buckets map[string]*neopb.TeamBucket) bool {
	cid := r.client.ID
	ipbuck, ok := buckets[cid]
	if !ok {
		logrus.Errorf("Failed to find IPs in state for client: %s", cid)
		return false
	}
	teams := ipbuck.GetTeams()

	r.teamsLock.Lock()
	defer r.teamsLock.Unlock()
	if diff := cmp.Diff(r.teams, teams, cmpopts.EquateEmpty()); diff != "" {
		r.teams = teams
		return true
	}
	return false
}

func (r *Runner) updateConfig(cfg *config.Config) {
	r.cfg = cfg
	select {
	case r.configUpdated <- struct{}{}:
	default:
	}
}

func (r *Runner) updateExploits(ctx context.Context, exs []*neopb.ExploitState) {
	restartEndless := r.storage.UpdateExploits(ctx, exs)
	if restartEndless {
		logrus.Info("Need to restart endless")
		r.restartEndless()
	}
}

func (r *Runner) printGreeting() {
	fmt.Println(`       _                                                               
   ___| |__  ___   _ __   ___  ___    _ __ _   _ _ __  _ __   ___ _ __ 
  / __| '_ \/ __| | '_ \ / _ \/ _ \  | '__| | | | '_ \| '_ \ / _ \ '__|
 | (__| |_) \__ \ | | | |  __/ (_) | | |  | |_| | | | | | | |  __/ |   
  \___|_.__/|___/ |_| |_|\___|\___/  |_|   \__,_|_| |_|_| |_|\___|_|   
                                                                       `)
}

func CreateExploitTasks(ex *State, teams map[string]string, environ []string) (tasks []queue.Task) {
	for id, ip := range teams {
		tasks = append(tasks, queue.NewTask(ex.ID, ex.Path, ex.Dir, id, ip, environ, ex.Timeout))
	}
	return
}
