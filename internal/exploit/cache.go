package exploit

import (
	"sync"
	"time"

	neopb "neo/lib/genproto/neo"
)

func NewCache() *Cache {
	return &Cache{
		states: make(map[string]*State),
		m:      sync.RWMutex{},
	}
}

// Cache represents the client local in-memory executable cache.
// Cache is NOT persistent now, so any client restart will cause a re-download of the all exploits.
type Cache struct {
	states map[string]*State
	m      sync.RWMutex
}

func (c *Cache) Exploits() (res []*State) {
	c.m.RLock()
	defer c.m.RUnlock()

	for _, v := range c.states {
		res = append(res, v)
	}
	return
}

func (c *Cache) Exploit(id string) (res *State, ok bool) {
	c.m.RLock()
	defer c.m.RUnlock()
	res, ok = c.states[id]
	return
}

func (c *Cache) Diff(exs []*neopb.ExploitState) (diff []*neopb.ExploitState, restartEndless bool) {
	c.m.RLock()
	defer c.m.RUnlock()
	for _, ex := range exs {
		state, exists := c.states[ex.GetExploitId()]
		if !exists {
			if ex.Endless {
				restartEndless = true
			}
			diff = append(diff, ex)
			continue
		}
		if state.Endless != ex.Endless {
			restartEndless = true
		}
		if state.Version != ex.GetVersion() {
			diff = append(diff, ex)
		}
	}
	return
}

func (c *Cache) Update(exs []*State) {
	c.m.Lock()
	defer c.m.Unlock()
	for _, ex := range exs {
		c.states[ex.ID] = ex
	}
}

func (c *Cache) UpdateLastRun(exploitID string, t time.Time) {
	c.m.Lock()
	defer c.m.Unlock()
	if ex, ok := c.states[exploitID]; ok {
		ex.LastRun = t
	}
}
