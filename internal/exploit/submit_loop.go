package exploit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"time"

	"neo/internal/config"

	"github.com/sirupsen/logrus"
)

const (
	// TODO: Change this to config parameter.
	submitEvery = time.Second * 2
)

type submitLoop struct {
	q       *Queue
	maxJobs int
	done    chan struct{}
	mu      sync.Mutex
	cfg     *config.Config
}

func NewSubmitLoop(maxJobs int, cfg *config.Config) *submitLoop {
	return &submitLoop{
		q:       NewQueue(maxJobs),
		maxJobs: maxJobs,
		done:    make(chan struct{}),
		cfg:     cfg,
	}
}

func (l *submitLoop) Run(ctx context.Context) {
	defer logrus.Info("Submit loop stopped")

	l.q.Run(ctx)
	defer l.q.Stop()

	t := time.NewTicker(submitEvery)
	defer t.Stop()

	var results []Result

	flush := func() {
		if len(results) == 0 {
			return
		}
		logrus.Infof("Submitting %d flags", len(results))
		logrus.Debugf("Flags: %+v", results)
		if err := l.submit(results); err != nil {
			logrus.Errorf("Failed to submit flags to farm: %v", err)
		} else {
			logrus.Infof("Sent %d flags to the farm", len(results))
			results = make([]Result, 0)
		}
	}
	defer flush()
	defer logrus.Info("Shutting down submit loop")

	for {
		select {
		case res, ok := <-l.q.Output:
			if !ok {
				logrus.Warningf("Queue finished unexpectedly, restarting")
				l.q = NewQueue(l.maxJobs)
				l.q.Run(ctx)
				break
			}

			for _, match := range l.cfg.FlagRegexp.FindAll(res.Out, -1) {
				results = append(results, Result{
					Flag:    string(match),
					Exploit: res.Name,
					Team:    res.Team,
				})
			}
		case <-t.C:
			flush()
		case <-l.done:
			return
		case <-ctx.Done():
			return
		}
	}
}

func (l *submitLoop) Add(t Task) error {
	return l.q.Add(t)
}

func (l *submitLoop) Stop() {
	close(l.done)
}

func (l *submitLoop) submit(results []Result) error {
	// For destructive farm only now.
	url := l.cfg.FarmUrl + "/api/post_flags"

	for i := range results {
		results[i].Exploit = "[neo] " + results[i].Exploit
	}

	data, err := json.Marshal(results)
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", url, bytes.NewReader(data))
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", l.cfg.FarmPassword)
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			logrus.Errorf("Error closing submission response body: %v", err)
		}
	}()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to submit flags to farm with code = %d", resp.StatusCode)
	}
	return err
}
