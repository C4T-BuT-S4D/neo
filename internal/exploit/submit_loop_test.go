package exploit

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"regexp"
	"sync"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/goleak"

	"github.com/c4t-but-s4d/neo/v2/internal/config"
	"github.com/c4t-but-s4d/neo/v2/internal/logger"
	"github.com/c4t-but-s4d/neo/v2/internal/models"
	"github.com/c4t-but-s4d/neo/v2/internal/queue"
	"github.com/c4t-but-s4d/neo/v2/pkg/joblogger"
	"github.com/c4t-but-s4d/neo/v2/pkg/neosync"
	"github.com/c4t-but-s4d/neo/v2/pkg/testutils"
)

var (
	errQueueFull = errors.New("queue is full")
)

func TestMain(m *testing.M) {
	logger.Init()
	goleak.VerifyTestMain(m)
}

func Test_newSubmitLoop(t *testing.T) {
	q := newMockQueue()
	factory := &mockQueueFactory{
		q: q,
	}
	cfg := config.ExploitsConfig{
		FarmURL:      "127.0.0.1",
		FarmPassword: "1234",
	}

	want := submitLoop{
		q:       q,
		maxJobs: 5,
		cfg:     &cfg,
		factory: factory,
	}

	got := newSubmitLoop(5, &cfg, NewMetrics(testutils.MetricsNamespace()), factory)

	assert.Equal(t, want.maxJobs, got.maxJobs)
	assert.Equal(t, want.cfg, got.cfg)
	assert.Equal(t, want.q, got.q)
}

func Test_submitLoop_Add(t *testing.T) {
	q := newMockQueue()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	go q.Start(ctx)

	factory := &mockQueueFactory{q: q}
	cfg := config.ExploitsConfig{
		FarmURL:      "127.0.0.1",
		FarmPassword: "1234",
	}
	sl := newSubmitLoop(1, &cfg, NewMetrics(testutils.MetricsNamespace()), factory)

	sender := joblogger.NewRemoteSender(nil)
	jobLogger := joblogger.New("id", 1, "127.0.0.1", sender)
	job := queue.NewJob(
		&models.Exploit{ID: "id", Version: 1, Type: models.ExploitTypeRecurrent},
		&models.Target{ID: "12", IP: "127.0.0.1"},
		"echo",
		"",
		nil,
		time.Second*5,
		jobLogger,
	)
	require.NoError(t, sl.Add(job), "Add() returned an unexpected error")

	select {
	case got := <-q.in:
		require.Equal(t, got.String(), job.String(), "invalid job added")
	default:
		t.Errorf("Add(): queue is empty after adding job")
	}
}

func Test_submitLoop_AddFullQueue(t *testing.T) {
	q := &mockQueue{}
	factory := &mockQueueFactory{q: q}

	cfg := config.ExploitsConfig{
		FarmURL:      "127.0.0.1",
		FarmPassword: "1234",
	}
	sl := newSubmitLoop(1, &cfg, NewMetrics(testutils.MetricsNamespace()), factory)

	sender := joblogger.NewRemoteSender(nil)
	jobLogger := joblogger.New("id", 1, "127.0.0.1", sender)
	job := queue.NewJob(
		&models.Exploit{ID: "id", Version: 1, Type: models.ExploitTypeRecurrent},
		&models.Target{ID: "12", IP: "127.0.0.1"},
		"echo",
		"",
		nil,
		time.Second*5,
		jobLogger,
	)
	// in/out are nil, so queue is always full.
	require.ErrorIs(t, sl.Add(job), errQueueFull, "Add() did not return an error")
}

func Test_submitLoop_Run(t *testing.T) {
	q := newMockQueue()
	factory := &mockQueueFactory{q: q}

	wg := sync.WaitGroup{}

	wantResults := []*FarmRequest{
		{
			Flag:    "AAAAA=",
			Exploit: "[neo] test",
			Team:    "Target 1",
		},
		{
			Flag:    "BBBBB=",
			Exploit: "[neo] another test",
			Team:    "Target 2",
		},
	}
	outputs := []*queue.Output{
		{
			Exploit: &models.Exploit{ID: "test"},
			Target:  &models.Target{ID: "Target 1"},
			Out:     []byte("some large AAAAA= output"),
		},
		{
			Exploit: &models.Exploit{ID: "another test"},
			Target:  &models.Target{ID: "Target 2"},
			Out:     []byte("some large BBBBB= output"),
		},
	}

	wg.Add(1) // checker must be called once
	checker := func(t *testing.T, r *http.Request) {
		t.Helper()
		t.Log("checker called")
		defer t.Log("checker finished")
		defer wg.Done()

		auth := r.Header.Get("Authorization")
		token := r.Header.Get("X-Token")
		contentType := r.Header.Get("Content-Type")
		require.Equal(t, "1234", auth, "Invalid auth header %v", auth)
		require.Equal(t, auth, token, "Invalid X-Token header %v", token)
		require.Equal(t, "application/json", contentType, "Invalid content type %v", contentType)

		var results []*FarmRequest
		err := json.NewDecoder(r.Body).Decode(&results)
		require.NoError(t, err, "Could not json-decode request body: %v", err)

		t.Logf("checker received results: %v", results)

		diff := cmp.Diff(results, wantResults)
		require.Equal(t, "", diff, "Invalid results returned: %v", diff)
	}
	s := testutils.NewCheckedTestServer(t, checker)
	defer s.Close()

	cfg := config.ExploitsConfig{
		FarmURL:      s.URL,
		FarmPassword: "1234",
		FlagRegexp:   regexp.MustCompile("[AB]{5}="),
		SubmitEvery:  time.Second,
	}
	sl := newSubmitLoop(1, &cfg, NewMetrics(testutils.MetricsNamespace()), factory)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	slDone := make(chan struct{})
	go func() {
		defer close(slDone)
		defer t.Logf("Submit loop stopped")
		sl.Start(ctx)
	}()

	wg.Add(1) // outputs must be added
	go func() {
		defer wg.Done()
		for _, out := range outputs {
			t.Logf("sending output %v", out)
			q.out <- out
		}
	}()

	// wait for results
	select {
	case <-time.After(cfg.SubmitEvery * 2):
		t.Errorf("Run(): test timed out")
	case <-neosync.AwaitWG(&wg):
		// Wait for submit request to finish to avoid errors.
		time.Sleep(time.Millisecond * 200)
	}

	done := make(chan struct{})
	go func() {
		defer close(done)
		cancel()
		<-slDone // wait for submit loop to stop
	}()

	// gracefully stop the queue
	select {
	case <-time.After(time.Millisecond * 100):
		t.Errorf("Run(): stop timed out")
	case <-done:
	}
}

func Test_submitLoop_submitResults(t *testing.T) {
	tests := []struct {
		name        string
		ctx         context.Context
		sendResults []*FullResult
		wantResults []*FarmRequest
		wantRequest bool
		wantErr     error
	}{
		{
			"simple",
			context.Background(),
			[]*FullResult{
				{
					&models.Exploit{ID: "exploit"},
					&models.Target{ID: "team"},
					"AAAAA=",
				},
			},
			[]*FarmRequest{
				{
					"AAAAA=",
					"[neo] exploit",
					"team",
				},
			},
			true,
			nil,
		},
		{
			"cancelled context",
			testutils.CanceledContext(),
			[]*FullResult{
				{
					&models.Exploit{ID: "exploit"},
					&models.Target{ID: "team"},
					"AAAAA=",
				},
			},
			nil,
			false,
			context.Canceled,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := testutils.NewCheckedTestServer(t, func(t *testing.T, r *http.Request) {
				t.Helper()
				t.Log("checker called")
				defer t.Log("checker finished")

				require.True(t, tt.wantRequest, "Unexpected request was made")

				auth := r.Header.Get("Authorization")
				token := r.Header.Get("X-Token")
				contentType := r.Header.Get("Content-Type")
				require.Equal(t, "1234", auth, "Invalid auth header %v", auth)
				require.Equal(t, auth, token, "Invalid X-Token header %v", token)
				require.Equal(t, "application/json", contentType, "Invalid content type %v", contentType)

				var results []*FarmRequest
				err := json.NewDecoder(r.Body).Decode(&results)
				require.NoError(t, err, "Could not json-decode request body: %v", err)

				t.Logf("checker received results: %v", results)

				diff := cmp.Diff(results, tt.wantResults)
				require.Equal(t, "", diff, "Invalid results returned: %v", diff)
			})
			defer s.Close()

			loop := newSubmitLoop(
				1,
				&config.ExploitsConfig{
					FarmURL:      s.URL,
					FarmPassword: "1234",
				},
				NewMetrics(testutils.MetricsNamespace()),
				&mockQueueFactory{},
			)
			require.ErrorIs(t, loop.submitResults(tt.ctx, tt.sendResults), tt.wantErr)
		})
	}
}

type mockQueue struct {
	out chan *queue.Output
	in  chan *queue.Job
}

func (m *mockQueue) String() string {
	return "MockQueue"
}

func newMockQueue() *mockQueue {
	return &mockQueue{
		in:  make(chan *queue.Job, 100),
		out: make(chan *queue.Output, 100),
	}
}

func (m *mockQueue) Type() queue.Type {
	return "mock"
}

func (m *mockQueue) Size() int {
	return len(m.in)
}

func (m *mockQueue) Start(ctx context.Context) {
	<-ctx.Done()
}

func (m *mockQueue) Add(job *queue.Job) error {
	select {
	case m.in <- job:
		return nil
	default:
		return errQueueFull
	}
}

func (m *mockQueue) Stop() {
	close(m.in)
	close(m.out)
}

func (m *mockQueue) Results() <-chan *queue.Output {
	return m.out
}

type mockQueueFactory struct {
	q *mockQueue
}

func (m mockQueueFactory) Create(int) queue.Queue {
	if m.q == nil {
		m.q = newMockQueue()
	}
	return m.q
}

func (m mockQueueFactory) Type() queue.Type {
	return "mock"
}
