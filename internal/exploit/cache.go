package exploit

import (
	"sync"

	neopb "neo/lib/genproto/neo"
)

func NewCache() *Cache {
	return &Cache{
		states: make(map[string]State),
		m:      sync.RWMutex{},
	}
}

// Cache represents the client local in-memory exploit cache.
type Cache struct {
	states map[string]State
	m      sync.RWMutex
}

func (c *Cache) Exploits() (res []State) {
	c.m.RLock()
	defer c.m.RUnlock()

	for _, v := range c.states {
		res = append(res, v)
	}
	return
}

func (c *Cache) Diff(exs []*neopb.ExploitState) []*neopb.ExploitState {
	c.m.RLock()
	defer c.m.RUnlock()
	var diff []*neopb.ExploitState
	for _, ex := range exs {
		state, exists := c.states[ex.GetExploitId()]
		if !exists {
			diff = append(diff, ex)
			continue
		}
		if state.Version != ex.GetVersion() {
			diff = append(diff, ex)
		}
	}
	return diff
}

func (c *Cache) Update(exs []State) {
	c.m.Lock()
	defer c.m.Unlock()
	for _, ex := range exs {
		c.states[ex.ID] = ex
	}
}
