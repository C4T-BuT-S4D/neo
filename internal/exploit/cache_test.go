package exploit

import (
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"google.golang.org/protobuf/testing/protocmp"

	neopb "neo/lib/genproto/neo"
)

func TestCache_Diff(t *testing.T) {
	for _, tc := range []struct {
		have []*State
		new  []*neopb.ExploitState
		diff []*neopb.ExploitState
		re   bool
	}{
		{
			have: nil,
			new:  nil,
			diff: nil,
			re:   false,
		},
		{
			have: []*State{
				{ID: "1", Version: 1},
			},
			new: []*neopb.ExploitState{{
				ExploitId: "1",
				Version:   1,
				File:      nil,
			}},
			diff: nil,
			re:   false,
		},
		{
			have: []*State{
				{ID: "1", Version: 1},
			},
			new: []*neopb.ExploitState{{
				ExploitId: "2",
				Version:   1,
				File:      nil,
			}},
			diff: []*neopb.ExploitState{{
				ExploitId: "2",
				Version:   1,
				File:      nil,
			}},
			re: false,
		},
		{
			have: []*State{
				{ID: "1", Version: 1},
			},
			new: []*neopb.ExploitState{{
				ExploitId: "1",
				Version:   2,
				File:      nil,
			}},
			diff: []*neopb.ExploitState{{
				ExploitId: "1",
				Version:   2,
				File:      nil,
			}},
			re: false,
		},
		{
			have: []*State{
				{ID: "1", Version: 1},
				{ID: "2", Version: 1},
			},
			new: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					File:      nil,
				},
				{
					ExploitId: "2",
					Version:   1,
					File:      nil,
				},
				{
					ExploitId: "3",
					Version:   1,
					File:      nil,
				},
			},
			diff: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					File:      nil,
				},
				{
					ExploitId: "3",
					Version:   1,
					File:      nil,
				},
			},
			re: false,
		},
		{
			have: []*State{
				{ID: "1", Version: 1},
				{ID: "2", Version: 1},
			},
			new:  nil,
			diff: nil,
			re:   false,
		},
		{
			have: []*State{
				{ID: "1", Version: 1, Endless: false},
			},
			new: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   true,
				},
			},
			diff: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   true,
				},
			},
			re: true,
		},
		{
			have: []*State{
				{ID: "1", Version: 1, Endless: true},
			},
			new: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   false,
				},
			},
			diff: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   false,
				},
			},
			re: true,
		},
		{
			have: nil,
			new: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   true,
				},
			},
			diff: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   true,
				},
			},
			re: true,
		},
		{
			have: nil,
			new: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   false,
				},
			},
			diff: []*neopb.ExploitState{
				{
					ExploitId: "1",
					Version:   2,
					Endless:   false,
				},
			},
			re: false,
		},
	} {
		c := NewCache()
		c.Update(tc.have)
		got, re := c.Diff(tc.new)
		if diff := cmp.Diff(tc.diff, got, protocmp.Transform(), cmpopts.EquateEmpty()); diff != "" {
			t.Errorf("Diff() mismatch (-want +got):\n%s", diff)
		}
		if re != tc.re {
			t.Errorf("Diff(): expected restartEndless = %t, got = %t", tc.re, re)
		}
	}
}

func TestCache_Exploits(t *testing.T) {
	c := NewCache()
	data := []*State{{
		ID:      "1",
		Version: 1,
		Dir:     "/test",
		Path:    "kek",
	}}
	c.Update(data)
	if diff := cmp.Diff(data, c.Exploits(), cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Diff() mismatch (-want +got):\n%s", diff)
	}
}
