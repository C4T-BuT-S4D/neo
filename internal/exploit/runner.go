package exploit

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/sirupsen/logrus"

	"neo/internal/client"
	"neo/internal/config"

	neopb "neo/lib/genproto/neo"
)

func NewRunner(maxJobs int, dir string, c *client.Client) *Runner {
	return &Runner{
		dir:        dir,
		cache:      NewCache(),
		cfg:        &config.Config{},
		client:     c,
		maxJobs:    maxJobs,
		singleRuns: make(chan *neopb.ExploitRequest),
	}
}

type Runner struct {
	cache      *Cache
	teams      map[string]string
	dir        string
	cfg        *config.Config
	client     *client.Client
	maxJobs    int
	pingTicker *time.Ticker

	cfgLock   sync.Mutex
	teamsLock sync.RWMutex

	singleRuns chan *neopb.ExploitRequest
}

func (r *Runner) Run(ctx context.Context) error {
	r.printGreeting()

	state, err := r.pingHeartbeat(ctx)
	if err != nil {
		return fmt.Errorf("sending heartbeat: %w", err)
	}

	r.updateTeams(state.GetClientTeamMap())
	defer r.pingTicker.Stop()

	wg := new(sync.WaitGroup)

	srvCtx, srvCancel := context.WithCancel(ctx)
	defer srvCancel()

	if err := r.listenBroadcast(srvCtx, wg); err != nil {
		return fmt.Errorf("starting broadcast listener: %w", err)
	}
	if err := r.listenSingleRuns(srvCtx, wg); err != nil {
		return fmt.Errorf("starting single run listener: %w", err)
	}
	defer func() {
		logrus.Info("Stopping aux services")
		srvCancel()
		logrus.Info("Waiting for aux services to stop")
		wg.Wait()
	}()

	r.eventLoop(ctx)

	logrus.Info("Worker is finishing, sending the leave ping")
	leaveCtx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	if _, err := r.client.Ping(leaveCtx, neopb.PingRequest_LEAVE); err != nil {
		return fmt.Errorf("failed to send leave ping: %w", err)
	}

	return nil
}

func (r *Runner) pingHeartbeat(ctx context.Context) (*neopb.ServerState, error) {
	state, err := r.client.Ping(ctx, neopb.PingRequest_HEARTBEAT)
	if err != nil {
		return nil, fmt.Errorf("sending ping request: %w", err)
	}
	cfg, err := config.FromProto(state.GetConfig())
	if err != nil {
		return nil, fmt.Errorf("parsing config: %w", err)
	}
	r.updateConfig(cfg)
	r.updateExploits(ctx, state.GetExploits())
	return state, nil
}

func (r *Runner) eventLoop(ctx context.Context) {
	defer logrus.Info("Ping loop stopped")

	sl := newSubmitLoop(r.maxJobs, r.cfg)
	go sl.Run(ctx)
	defer sl.Stop()

	runTicker := time.NewTicker(time.Second)
	defer runTicker.Stop()

	// Run exploits immediately.
	r.submitExploits(sl)

	for {
		select {
		case <-r.pingTicker.C:
			state, err := r.pingHeartbeat(ctx)
			if err != nil {
				logrus.Errorf("Error sending recurrent heartbeat: %v", err)
			}
			if r.updateTeams(state.GetClientTeamMap()) {
				// Restart the queue: will kill all the existing exploits and clear the queue.
				logrus.Info("Stopping submit loop")
				sl.Stop()
				logrus.Info("Recreating submit loop")
				sl = newSubmitLoop(r.maxJobs, r.cfg)
				go sl.Run(ctx)
			}

		case <-runTicker.C:
			r.submitExploits(sl)

		case req := <-r.singleRuns:
			logrus.Infof("Processing single run request %v", req)

			// Update config to guarantee the requested exploit exists locally.
			if _, err := r.pingHeartbeat(ctx); err != nil {
				logrus.Errorf("Error updating config before single run: %v", err)
			}
			r.submitExploit(sl, req.ExploitId)

		case <-ctx.Done():
			return
		}
	}
}

func (r *Runner) submitExploits(sl *submitLoop) {
	exs := r.cache.Exploits()
	now := time.Now()
	for _, ex := range exs {
		if ex.Disabled {
			continue
		}
		if ex.LastRun.Add(ex.RunEvery).After(now) {
			continue
		}
		r.submitExploit(sl, ex.ID)
	}
}

func (r *Runner) submitExploit(sl *submitLoop, id string) {
	if ex, ok := r.cache.Exploit(id); ok {
		r.teamsLock.RLock()
		defer r.teamsLock.RUnlock()

		for id, ip := range r.teams {
			t := NewTask(ex, id, ip, r.cfg.Environ, ex.Timeout)
			logrus.Infof("Adding task: %+v", t)
			if err := sl.Add(t); err != nil {
				logrus.Errorf("Failed to add %v to queue: %v", t, err)
			}
		}
		r.cache.UpdateLastRun(ex.ID, time.Now())
	}
}

func (r *Runner) listenBroadcast(ctx context.Context, wg *sync.WaitGroup) error {
	resp, err := r.client.ListenBroadcasts(ctx)
	if err != nil {
		return fmt.Errorf("making broadcasts listen request: %w", err)
	}
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case cmd, ok := <-resp:
				if !ok {
					logrus.Infof("Broadcast channel was closed, exiting")
					return
				}
				logrus.Infof("Received a command from broadcast: %v", cmd)
				if err := r.handleBroadcastCommand(ctx, cmd); err != nil {
					logrus.Errorf("Error running broadcast command: %v", err)
				}
			case <-ctx.Done():
				return
			}
		}
	}()
	return nil
}

func (r *Runner) listenSingleRuns(ctx context.Context, wg *sync.WaitGroup) error {
	resp, err := r.client.ListenSingleRuns(ctx)
	if err != nil {
		return fmt.Errorf("making single run listen request: %w", err)
	}
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case req, ok := <-resp:
				if !ok {
					logrus.Infof("Single run channel was closed, exiting")
					return
				}
				logrus.Infof("Received a single run request: %v", req)
				r.singleRuns <- req
			case <-ctx.Done():
				return
			}
		}
	}()
	return nil
}

func (r *Runner) handleBroadcastCommand(ctx context.Context, cmd *neopb.Command) error {
	c := exec.CommandContext(ctx, "/bin/bash", "-c", cmd.Command)
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	if err := c.Run(); err != nil {
		return fmt.Errorf("executing command: %w", err)
	}
	return nil
}

func (r *Runner) updateTeams(buckets map[string]*neopb.TeamBucket) bool {
	cid := r.client.ID
	ipbuck, ok := buckets[cid]
	if !ok {
		logrus.Errorf("Failed to find IPs in state for client: %s", cid)
		return false
	}
	teams := ipbuck.GetTeams()

	r.teamsLock.Lock()
	defer r.teamsLock.Unlock()
	if diff := cmp.Diff(r.teams, teams, cmpopts.EquateEmpty()); diff != "" {
		r.teams = teams
		return true
	}
	return false
}

func (r *Runner) updateConfig(cfg *config.Config) {
	r.cfgLock.Lock()
	defer r.cfgLock.Unlock()

	if cfg.PingEvery != r.cfg.PingEvery {
		if r.pingTicker != nil {
			r.pingTicker.Stop()
		}
		r.pingTicker = time.NewTicker(cfg.PingEvery)
	}
	r.cfg = cfg
}

func (r *Runner) updateExploits(ctx context.Context, exs []*neopb.ExploitState) {
	diff := r.cache.Diff(exs)
	if len(diff) > 0 {
		logrus.Infof("Got %d updated exploits: %v", len(diff), diff)
	}

	states := make([]*State, 0, len(diff))
	for _, ex := range diff {
		st, err := r.updateExploit(ctx, ex)
		if err != nil {
			logrus.Errorf("Failed to update/download executable(%s:%d): %v", ex.GetExploitId(), ex.GetVersion(), err)
			continue
		}
		states = append(states, st)
	}
	r.cache.Update(states)
}

func (r *Runner) updateExploit(ctx context.Context, state *neopb.ExploitState) (*State, error) {
	// Download the current exploit state.
	curState, err := r.client.Exploit(ctx, state.GetExploitId())
	if err != nil {
		return nil, fmt.Errorf("requesting exploit state: %w", err)
	}
	cfg := curState.GetConfig()

	runEvery, err := time.ParseDuration(cfg.GetRunEvery())
	if err != nil {
		return nil, fmt.Errorf("could not parse run every: %w", err)
	}

	timeout, err := time.ParseDuration(cfg.GetTimeout())
	if err != nil {
		return nil, fmt.Errorf("could not parse timeout: %w", err)
	}

	// Create temp file for download.
	f, err := ioutil.TempFile(r.dir, "DOWNLOAD")
	if err != nil {
		return nil, fmt.Errorf("creating temp file: %w", err)
	}
	defer func() {
		_ = f.Close()
		_ = os.Remove(f.Name())
	}()

	// Download the executable to temp file.
	if err := r.client.DownloadFile(ctx, state.GetFile(), f); err != nil {
		return nil, fmt.Errorf("downloading file: %w", err)
	}
	// Seek to beginning to use file as an io.Reader.
	if _, err := f.Seek(0, io.SeekStart); err != nil {
		return nil, fmt.Errorf("seeking downloaded file: %w", err)
	}

	oPath := filepath.Join(r.dir, fmt.Sprintf("%s_%d", state.GetExploitId(), state.GetVersion()))

	var entryPath string
	if entryPath, err = saveExploit(f, oPath, cfg); err != nil {
		return nil, fmt.Errorf("saving exploit: %w", err)
	}
	logrus.Infof("path = %s, entry = %s", oPath, entryPath)

	if entryPath, err = prepareEntry(entryPath); err != nil {
		return nil, fmt.Errorf("prepairing entry: %w", err)
	}

	res := &State{
		ID:       state.GetExploitId(),
		Version:  state.GetVersion(),
		Dir:      "",
		Path:     entryPath,
		Disabled: state.GetDisabled(),
		LastRun:  time.Unix(0, 0),
		RunEvery: runEvery,
		Timeout:  timeout,
	}
	if cfg.GetIsArchive() {
		res.Dir = oPath
	}
	return res, nil
}

func (r *Runner) printGreeting() {
	fmt.Println(`       _                                                               
   ___| |__  ___   _ __   ___  ___    _ __ _   _ _ __  _ __   ___ _ __ 
  / __| '_ \/ __| | '_ \ / _ \/ _ \  | '__| | | | '_ \| '_ \ / _ \ '__|
 | (__| |_) \__ \ | | | |  __/ (_) | | |  | |_| | | | | | | |  __/ |   
  \___|_.__/|___/ |_| |_|\___|\___/  |_|   \__,_|_| |_|_| |_|\___|_|   
                                                                       `)
}
