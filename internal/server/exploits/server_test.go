package exploits

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/testing/protocmp"
	"google.golang.org/protobuf/types/known/durationpb"

	"github.com/c4t-but-s4d/neo/v2/internal/server/config"
	"github.com/c4t-but-s4d/neo/v2/pkg/hostbucket"
	epb "github.com/c4t-but-s4d/neo/v2/pkg/proto/exploits"
	fspb "github.com/c4t-but-s4d/neo/v2/pkg/proto/fileserver"
)

func testServer(t *testing.T) (*Server, func()) {
	t.Helper()

	db, cleanupDB := testDB()
	st, err := NewStorage(db)
	require.NoError(t, err)

	require.NoError(t, err)

	cfg := &config.Config{
		BaseDir:          t.TempDir(),
		MetricsNamespace: fmt.Sprintf("tests_%s", uuid.NewString()[:8]),
	}
	es := New(cfg, st)
	return es, cleanupDB
}

func TestServer_UpdateExploit(t *testing.T) {
	es, clean := testServer(t)
	defer clean()
	cfg := &epb.ExploitConfiguration{
		Entrypoint: "bin",
		IsArchive:  false,
		Timeout:    durationpb.New(time.Minute),
		RunEvery:   durationpb.New(time.Minute),
	}
	r := &epb.UpdateExploitRequest{
		State: &epb.ExploitState{
			ExploitId: "1",
			File:      &fspb.FileInfo{Uuid: "1"},
			Config:    cfg,
		},
	}
	resp, err := es.UpdateExploit(context.Background(), r)
	require.NoError(t, err)

	cfg.Timeout = durationpb.New(2 * time.Minute)
	cfg.RunEvery = durationpb.New(2 * time.Minute)
	want := &epb.ExploitState{
		ExploitId: "1",
		Version:   1,
		File:      r.State.File,
		Config:    cfg,
	}
	if diff := cmp.Diff(want, resp.State, protocmp.Transform()); diff != "" {
		t.Errorf("UpdateExploit() mismatch (-want +got):\n%s", diff)
	}
}

func TestServer_Exploit(t *testing.T) {
	es, clean := testServer(t)
	defer clean()
	cfg := &epb.ExploitConfiguration{
		Entrypoint: "bin",
		IsArchive:  false,
		Timeout:    durationpb.New(time.Minute),
		RunEvery:   durationpb.New(time.Minute),
	}
	state := &epb.ExploitState{
		ExploitId: "1",
		File:      &fspb.FileInfo{Uuid: "1"},
		Config:    cfg,
	}
	req := &epb.UpdateExploitRequest{State: state}
	ctx := context.Background()
	_, err := es.UpdateExploit(ctx, req)
	require.NoError(t, err)
	resp, err := es.Exploit(ctx, &epb.ExploitRequest{ExploitId: state.ExploitId})
	require.NoError(t, err)
	wantState := &epb.ExploitState{
		ExploitId: "1",
		Version:   1,
		File:      state.File,
		Config:    cfg,
	}
	if diff := cmp.Diff(wantState, resp.State, protocmp.Transform()); diff != "" {
		t.Errorf("Exploit() state mismatch (-want +got):\n%s", diff)
	}
}

func TestServer_Ping(t *testing.T) {
	es, clean := testServer(t)
	defer clean()
	es.buckets = hostbucket.New(map[string]string{"id1": "ip1", "id2": "ip2"})
	es.config.FarmURL = "test"
	ctx := context.Background()
	cfg := &epb.ExploitConfiguration{
		Entrypoint: "bin",
		IsArchive:  false,
		Timeout:    durationpb.New(time.Minute),
		RunEvery:   durationpb.New(time.Minute),
	}
	state := &epb.ExploitState{
		ExploitId: "1",
		File:      &fspb.FileInfo{Uuid: "1"},
		Config:    cfg,
	}
	r := &epb.UpdateExploitRequest{State: state}
	updateResp, err := es.UpdateExploit(ctx, r)
	require.NoError(t, err)

	const clientID = "id1"
	req := &epb.PingRequest{
		ClientId: clientID,
		Payload: &epb.PingRequest_HeartbeatRequest{
			HeartbeatRequest: &epb.PingRequest_Heartbeat{},
		},
	}
	resp, err := es.Ping(ctx, req)
	require.NoError(t, err)
	want := []*epb.ExploitState{updateResp.State}
	if diff := cmp.Diff(want, resp.State.Exploits, protocmp.Transform()); diff != "" {
		t.Errorf("Ping() states mismatch (-want +got):\n%s", diff)
	}
	if diff := cmp.Diff(es.buckets.Buckets(), resp.State.ClientTeamMap, protocmp.Transform()); diff != "" {
		t.Errorf("Ping() bucket mismatch (-want +got):\n%s", diff)
	}
	require.NotEmpty(t, es.buckets.Buckets()[clientID].Teams)
	require.Equal(t, es.config.FarmURL, resp.State.Config.FarmUrl)
	require.True(t, es.visits.visits["id1"].Before(time.Now()))
}

func TestServer_BroadcastCommand(t *testing.T) {
	es, clean := testServer(t)
	defer clean()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	var received *epb.BroadcastRequest
	signal := make(chan struct{})
	handler := func(msg *epb.BroadcastRequest) error {
		received = msg
		close(signal)
		return nil
	}
	testSub := es.broadcastPubSub.Subscribe(handler)
	defer es.broadcastPubSub.Unsubscribe(testSub)
	go testSub.Run(ctx)

	r := &epb.BroadcastRequest{Command: "echo 123"}
	_, err := es.BroadcastCommand(ctx, r)
	require.NoError(t, err)

	select {
	case <-signal:
		break
	case <-time.After(time.Millisecond * 100):
		t.Errorf("Handler was not called in time")
	}
	require.Equal(t, r, received)
}
