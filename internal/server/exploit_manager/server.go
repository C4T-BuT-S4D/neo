package exploit_manager

import (
	"context"
	"fmt"
	"regexp"
	"sync"
	"time"

	"github.com/c4t-but-s4d/neo/internal/config"
	"github.com/c4t-but-s4d/neo/internal/server/common"
	serverConfig "github.com/c4t-but-s4d/neo/internal/server/config"
	"github.com/c4t-but-s4d/neo/pkg/hostbucket"
	"github.com/c4t-but-s4d/neo/pkg/pubsub"
	empb "github.com/c4t-but-s4d/neo/proto/go/exploit_manager"

	"google.golang.org/grpc/codes"
	"google.golang.org/protobuf/types/known/emptypb"
)

func New(cfg *serverConfig.Config, storage *CachedStorage) *Server {
	ems := &Server{
		LoggingServer:   common.NewLoggingServer("exploit_manager"),
		storage:         storage,
		buckets:         hostbucket.New(cfg.FarmConfig.Teams),
		visits:          newVisitsMap(),
		singleRunPubSub: pubsub.NewPubSub[*empb.SingleRunRequest](),
		broadcastPubSub: pubsub.NewPubSub[*empb.Command](),
		metrics:         NewMetrics(cfg.MetricsNamespace),
	}
	ems.UpdateConfig(cfg)
	return ems
}

type Server struct {
	empb.UnimplementedServiceServer
	common.LoggingServer

	storage  *CachedStorage
	config   *config.ExploitsConfig
	cfgMutex sync.RWMutex
	buckets  *hostbucket.HostBucket
	visits   *visitsMap
	metrics  *Metrics

	singleRunPubSub *pubsub.PubSub[*empb.SingleRunRequest]
	broadcastPubSub *pubsub.PubSub[*empb.Command]
}

func (s *Server) Ping(ctx context.Context, r *empb.PingRequest) (*empb.PingResponse, error) {
	s.LogRequest(ctx, r)

	switch p := r.Payload.(type) {
	case *empb.PingRequest_ServerInfoRequest:
		// Just skip it.
	case *empb.PingRequest_HeartbeatRequest:
		s.cfgMutex.RLock()
		defer s.cfgMutex.RUnlock()
		s.visits.Add(p.HeartbeatRequest.ClientId)
		s.buckets.AddNode(p.HeartbeatRequest.ClientId, int(p.HeartbeatRequest.Weight))
	case *empb.PingRequest_LeaveRequest:
		s.visits.MarkInvalid(p.LeaveRequest.ClientId)
	default:
		return nil, s.WrapErrorf(ctx, codes.InvalidArgument, "Unknown payload type: %T", p)
	}

	return &empb.PingResponse{
		State: &empb.ServerState{
			ClientTeamMap: s.buckets.Buckets(),
			Exploits:      s.storage.States(),
			Config:        config.ToProto(s.config),
		},
	}, nil
}

func (s *Server) Exploit(ctx context.Context, r *empb.ExploitRequest) (*empb.ExploitResponse, error) {
	s.LogRequest(ctx, r)

	state, ok := s.storage.GetState(r.ExploitId)
	if !ok {
		return nil, s.WrapErrorf(ctx, codes.NotFound, "Failed to find an exploit state = %v", state.ExploitId)
	}
	return &empb.ExploitResponse{
		State: state,
	}, nil
}

func (s *Server) UpdateExploit(ctx context.Context, r *empb.UpdateExploitRequest) (*empb.UpdateExploitResponse, error) {
	s.LogRequest(ctx, r)

	newState, err := s.storage.UpdateExploitVersion(r.State)
	if err != nil {
		return nil, s.WrapErrorf(ctx, codes.Internal, "Failed to update exploit version: %v", err)
	}
	return &empb.UpdateExploitResponse{State: newState}, nil
}

func (s *Server) BroadcastCommand(ctx context.Context, r *empb.Command) (*emptypb.Empty, error) {
	s.LogRequest(ctx, r)

	s.broadcastPubSub.Publish(r)
	return &emptypb.Empty{}, nil
}

func (s *Server) BroadcastRequests(r *emptypb.Empty, stream empb.Service_BroadcastRequestsServer) error {
	s.LogRequest(stream.Context(), r)

	sub := s.broadcastPubSub.Subscribe(stream.Send)
	defer s.broadcastPubSub.Unsubscribe(sub)

	sub.Run(stream.Context())
	return nil
}

func (s *Server) SingleRun(ctx context.Context, r *empb.SingleRunRequest) (*emptypb.Empty, error) {
	s.LogRequest(ctx, r)

	s.singleRunPubSub.Publish(r)
	return &emptypb.Empty{}, nil
}

func (s *Server) SingleRunRequests(r *emptypb.Empty, stream empb.Service_SingleRunRequestsServer) error {
	s.LogRequest(stream.Context(), r)

	sub := s.singleRunPubSub.Subscribe(stream.Send)
	defer s.singleRunPubSub.Unsubscribe(sub)

	sub.Run(stream.Context())
	return nil
}

func (s *Server) HeartBeat(ctx context.Context) {
	ticker := time.NewTicker(s.config.PingEvery)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			s.Logger.Info("Checking clients")
			s.checkClients()
		case <-ctx.Done():
			return
		}
	}
}

func (s *Server) UpdateMetrics(ctx context.Context) {
	ticker := time.NewTicker(time.Second * 5)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			s.Logger.Info("Updating metrics")
			s.updateMetrics()
		case <-ctx.Done():
			return
		}
	}
}

func (s *Server) UpdateConfig(cfg *serverConfig.Config) {
	env := make([]string, 0, len(cfg.Environ))
	for k, v := range cfg.Environ {
		env = append(env, fmt.Sprintf("%s=%s", k, v))
	}

	s.cfgMutex.Lock()
	defer s.cfgMutex.Unlock()
	s.config = &config.ExploitsConfig{
		PingEvery:    cfg.PingEvery,
		SubmitEvery:  cfg.SubmitEvery,
		FarmURL:      cfg.FarmConfig.URL,
		FarmPassword: cfg.FarmConfig.Password,
		FlagRegexp:   regexp.MustCompile(cfg.FarmConfig.FlagRegexp),
		Environ:      env,
	}
	s.buckets.UpdateTeams(cfg.FarmConfig.Teams)
}

func (s *Server) checkClients() {
	alive, dead := s.visits.Invalidate(time.Now(), s.config.PingEvery)
	s.Logger.Infof("Heartbeat: got dead clients: %v, alive clients: %v", dead, alive)
	for _, c := range dead {
		s.buckets.DeleteNode(c)
	}
}

func (s *Server) updateMetrics() {
	s.metrics.AliveClients.Set(float64(s.visits.Size()))
}
