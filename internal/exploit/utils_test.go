package exploit

import (
	"context"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"

	"neo/pkg/testutils"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"

	neopb "neo/lib/genproto/neo"
)

func Test_saveExploit(t *testing.T) {
	f, err := ioutil.TempFile("", "")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err == nil {
			t.Errorf("Exploit file %s was not removed: %v", name, err)
		}
	}(f.Name())
	defer func(f *os.File) {
		if err := f.Close(); err == nil {
			t.Errorf("Exploit file was not closed: %v", err)
		}
	}(f)
	testData := []byte("test")
	if _, err := f.Write(testData); err != nil {
		t.Fatalf("f.WriteString() got unexpected error = %v", err)
	}

	outfile, err := ioutil.TempFile("", "")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	if err := outfile.Close(); err != nil {
		t.Fatalf("Close() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err != nil {
			t.Errorf("Error removing %s: %v", name, err)
		}
	}(outfile.Name())
	cfg := &neopb.ExploitConfiguration{
		Entrypoint: "kek",
		IsArchive:  false,
	}
	entry, err := saveExploit(f, outfile.Name(), cfg)
	if err != nil {
		t.Fatalf("Runner.saveExploit() got unexpected error = %v", err)
	}
	if entry != outfile.Name() {
		t.Fatalf("Runner.saveExploit() invalid entry returned = %v ", entry)
	}
	data, err := ioutil.ReadFile(outfile.Name())
	if err != nil {
		t.Fatalf("ioutil.ReadFile() got unexpected error = %v", err)
	}
	if diff := cmp.Diff(data, testData, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned data mismatch (-want +got):\n%s", diff)
	}
}

func Test_prepareEntry(t *testing.T) {
	f, err := ioutil.TempFile("", "exec")
	if err != nil {
		t.Fatalf("ioutil.TempFile() got unexpected error = %v", err)
	}
	defer func(name string) {
		if err := os.Remove(name); err != nil {
			t.Errorf("Error removing file %s: %v", name, err)
		}
	}(f.Name())
	if err := f.Close(); err != nil {
		t.Fatalf("Close() got unexpected error = %v", err)
	}
	entry, err := prepareEntry(f.Name())
	if err != nil {
		t.Fatalf("Runner.prepareEntry() got unexpected error = %v", err)
	}
	if !strings.Contains(entry, f.Name()) {
		t.Fatalf("Runner.prepareEntry() should return abs path, got = %v", entry)
	}
	fi, err := os.Stat(entry)
	if err != nil {
		t.Fatalf("os.Stat() got unexpected error = %v", err)
	}
	// Check that file is executable.
	if fi.Mode()&0111 == 0 {
		t.Errorf("Runner.prepareEntry() should make file executable, got = %v", fi.Mode())
	}
}

func Test_submitResults(t *testing.T) {
	tests := []struct {
		name        string
		ctx         context.Context
		sendResults []Result
		wantResults []Result
		wantRequest bool
		wantErr     error
	}{
		{
			"simple",
			context.Background(),
			[]Result{
				{
					"AAAAA=",
					"exploit",
					"team",
				},
			},
			[]Result{
				{
					"AAAAA=",
					"[neo] exploit",
					"team",
				},
			},
			true,
			nil,
		},
		{
			"cancelled context",
			testutils.CanceledContext(),
			[]Result{
				{
					"AAAAA=",
					"exploit",
					"team",
				},
			},
			nil,
			false,
			context.Canceled,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := testutils.NewCheckedTestServer(t, func(t *testing.T, r *http.Request) {
				t.Helper()
				t.Log("checker called")
				defer t.Log("checker finished")

				require.True(t, tt.wantRequest, "Unexpected request was made")

				auth := r.Header.Get("Authorization")
				token := r.Header.Get("X-Token")
				contentType := r.Header.Get("Content-Type")
				require.Equal(t, "1234", auth, "Invalid auth header %v", auth)
				require.Equal(t, auth, token, "Invalid X-Token header %v", token)
				require.Equal(t, "application/json", contentType, "Invalid content type %v", contentType)

				var results []Result
				err := json.NewDecoder(r.Body).Decode(&results)
				require.NoError(t, err, "Could not json-decode request body: %v", err)

				t.Logf("checker received results: %v", results)

				diff := cmp.Diff(results, tt.wantResults)
				require.Equal(t, "", diff, "Invalid results returned: %v", diff)
			})
			defer s.Close()

			if err := submitResults(tt.ctx, s.URL, "1234", tt.sendResults); !errors.Is(err, tt.wantErr) {
				t.Errorf("submitResults() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
