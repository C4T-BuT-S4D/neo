package exploit

import (
	"context"
	"fmt"
	"io"
	"os"
	"path"
	"strings"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/stretchr/testify/require"

	"github.com/c4t-but-s4d/neo/pkg/archive"
	epb "github.com/c4t-but-s4d/neo/proto/go/exploits"
)

func Test_saveExploit(t *testing.T) {
	f, err := os.CreateTemp("", "")
	require.NoError(t, err)
	defer func(f *os.File) {
		require.Error(t, f.Close())
		require.True(t, os.IsNotExist(os.Remove(f.Name())))
	}(f)
	testData := []byte("test")
	_, err = f.Write(testData)
	require.NoError(t, err)

	outfile, err := os.CreateTemp("", "")
	require.NoError(t, err)
	require.NoError(t, outfile.Close())
	defer func() {
		require.NoError(t, os.Remove(outfile.Name()))
	}()
	cfg := &epb.ExploitConfiguration{
		Entrypoint: "kek",
		IsArchive:  false,
	}
	entry, err := saveExploit(f, outfile.Name(), cfg)
	require.NoError(t, err)
	require.Equal(t, outfile.Name(), entry)

	data, err := os.ReadFile(outfile.Name())
	require.NoError(t, err)

	if diff := cmp.Diff(data, testData, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned data mismatch (-want +got):\n%s", diff)
	}
}

func Test_saveExploitArchive(t *testing.T) {
	dir, err := os.MkdirTemp("", "TEMP_TAR")
	require.NoError(t, err)

	remove := func(name string) {
		require.NoError(t, os.RemoveAll(name))
	}

	defer remove(dir)

	writeFile := func(name string, content []byte) error {
		f, err := os.Create(name)
		if err != nil {
			return fmt.Errorf("os.Create() got unexpected error = %w", err)
		}
		if _, err := f.Write(content); err != nil {
			return fmt.Errorf("f.Write() got unexpected error = %w", err)
		}
		if err := f.Close(); err != nil {
			return fmt.Errorf("f.Close() got unexpected error = %w", err)
		}
		return nil
	}

	exploitFile := "exp.py"
	exploitData := []byte("print(1);")
	require.NoError(t, writeFile(path.Join(dir, exploitFile), exploitData))

	secondFile := "t.txt"
	secondData := []byte("123")
	require.NoError(t, writeFile(path.Join(dir, secondFile), secondData))

	tarFile, err := os.CreateTemp("", "ARCHIVE")
	require.NoError(t, err)
	defer remove(tarFile.Name())

	require.NoError(t, archive.Tar(dir, tarFile))

	_, err = tarFile.Seek(0, io.SeekStart)
	require.NoError(t, err)

	outDir, err := os.MkdirTemp("", "TEMP_UNTAR")
	require.NoError(t, err)

	defer remove(outDir)

	cfg := &epb.ExploitConfiguration{
		Entrypoint: exploitFile,
		IsArchive:  true,
	}

	entry, err := saveExploit(tarFile, outDir, cfg)
	require.NoError(t, err)

	entryDir, entryPath := path.Split(entry)
	entryDir = path.Clean(entryDir)

	require.Equal(t, outDir, entryDir)
	require.Equal(t, cfg.Entrypoint, entryPath)

	entryContent, err := os.ReadFile(entry)
	require.NoError(t, err)

	if diff := cmp.Diff(exploitData, entryContent, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned entrypoint data mismatch (-want +got):\n%s", diff)
	}

	additionalContent, err := os.ReadFile(path.Join(entryDir, secondFile))
	require.NoError(t, err)

	if diff := cmp.Diff(secondData, additionalContent, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Runner.saveExploit() returned additional data mismatch (-want +got):\n%s", diff)
	}
}

func Test_prepareEntry(t *testing.T) {
	f, err := os.CreateTemp("", "exec")
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Remove(f.Name()))
	}()
	require.NoError(t, f.Close())

	entry, err := prepareEntry(f.Name())
	require.NoError(t, err)
	require.True(t, strings.Contains(entry, f.Name()))

	fi, err := os.Stat(entry)
	require.NoError(t, err)
	// Check that file is executable.
	require.NotZero(t, fi.Mode()&0111)
}

func Test_retryLoop(t *testing.T) {
	tests := []struct {
		name      string
		retries   int
		doRetries int
		returnErr error
		lastErr   error
		wantErr   error
	}{
		{
			"simple",
			1,
			1,
			ErrFinishedUnexpectedly,
			nil,
			nil,
		},
		{
			"endless retries",
			-1,
			100,
			ErrFinishedUnexpectedly,
			nil,
			nil,
		},
		{
			"return last error",
			1,
			5,
			io.EOF,
			nil,
			io.EOF,
		},
		{
			"context cancelled",
			5,
			3,
			ErrFinishedUnexpectedly,
			context.Canceled,
			context.Canceled,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cnt := 0
			f := func(context.Context) error {
				cnt++
				if cnt < tt.doRetries {
					return tt.returnErr
				}
				return tt.lastErr
			}
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			require.ErrorIs(t, retryLoop(ctx, "test", tt.retries, time.Millisecond, f), tt.wantErr)
			if tt.retries != -1 && tt.doRetries > tt.retries {
				require.Equal(t, tt.retries, cnt)
			} else {
				require.Equal(t, tt.doRetries, cnt)
			}
		})
	}
}
