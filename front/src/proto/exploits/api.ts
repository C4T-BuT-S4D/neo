// @ts-nocheck
/* eslint-disable */
import Long from "long";
import type { CallContext, CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal";
import { FileInfo } from "../fileserver/api";
import { Duration } from "../google/protobuf/duration";

export const protobufPackage = "exploits";

export interface TeamBucket {
  teams: Map<string, string>;
}

export interface TeamBucket_TeamsEntry {
  key: string;
  value: string;
}

export interface ExploitConfiguration {
  entrypoint: string;
  isArchive: boolean;
  runEvery: Duration | undefined;
  timeout: Duration | undefined;
  disabled: boolean;
  endless: boolean;
}

export interface ExploitState {
  exploitId: string;
  version: Long;
  file: FileInfo | undefined;
  config: ExploitConfiguration | undefined;
}

export interface Config {
  farmUrl: string;
  farmPassword: string;
  flagRegexp: string;
  pingEvery: Duration | undefined;
  submitEvery: Duration | undefined;
  environ: string[];
}

export interface ServerState {
  /** Ping distribution by client */
  clientTeamMap: Map<string, TeamBucket>;
  exploits: ExploitState[];
  config: Config | undefined;
}

export interface ServerState_ClientTeamMapEntry {
  key: string;
  value: TeamBucket | undefined;
}

export interface PingRequest {
  clientId: string;
  payload?:
    | { $case: "serverInfoRequest"; serverInfoRequest: PingRequest_ServerInfo }
    | { $case: "heartbeatRequest"; heartbeatRequest: PingRequest_Heartbeat }
    | { $case: "leaveRequest"; leaveRequest: PingRequest_Leave }
    | undefined;
}

export interface PingRequest_ServerInfo {
}

export interface PingRequest_Heartbeat {
  weight: number;
}

export interface PingRequest_Leave {
}

export interface PingResponse {
  state: ServerState | undefined;
}

export interface ExploitRequest {
  exploitId: string;
}

export interface ExploitResponse {
  state: ExploitState | undefined;
}

export interface UpdateExploitRequest {
  state: ExploitState | undefined;
}

export interface UpdateExploitResponse {
  state: ExploitState | undefined;
}

export interface BroadcastRequest {
  command: string;
}

export interface BroadcastResponse {
}

export interface BroadcastSubscribeRequest {
}

export interface BroadcastSubscribeResponse {
  command: string;
}

export interface SingleRunRequest {
  exploitId: string;
}

export interface SingleRunResponse {
}

export interface SingleRunSubscribeRequest {
}

export interface SingleRunSubscribeResponse {
  exploitId: string;
}

function createBaseTeamBucket(): TeamBucket {
  return { teams: new Map() };
}

export const TeamBucket = {
  encode(message: TeamBucket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    message.teams.forEach((value, key) => {
      TeamBucket_TeamsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeamBucket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = TeamBucket_TeamsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.teams.set(entry1.key, entry1.value);
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamBucket {
    return {
      teams: isObject(object.teams)
        ? Object.entries(object.teams).reduce<Map<string, string>>((acc, [key, value]) => {
          acc.set(key, String(value));
          return acc;
        }, new Map())
        : new Map(),
    };
  },

  toJSON(message: TeamBucket): unknown {
    const obj: any = {};
    if (message.teams?.size) {
      obj.teams = {};
      message.teams.forEach((v, k) => {
        obj.teams[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamBucket>, I>>(base?: I): TeamBucket {
    return TeamBucket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamBucket>, I>>(object: I): TeamBucket {
    const message = createBaseTeamBucket();
    message.teams = (() => {
      const m = new Map();
      (object.teams as Map<string, string> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, globalThis.String(value));
        }
      });
      return m;
    })();
    return message;
  },
};

function createBaseTeamBucket_TeamsEntry(): TeamBucket_TeamsEntry {
  return { key: "", value: "" };
}

export const TeamBucket_TeamsEntry = {
  encode(message: TeamBucket_TeamsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeamBucket_TeamsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamBucket_TeamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamBucket_TeamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TeamBucket_TeamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamBucket_TeamsEntry>, I>>(base?: I): TeamBucket_TeamsEntry {
    return TeamBucket_TeamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamBucket_TeamsEntry>, I>>(object: I): TeamBucket_TeamsEntry {
    const message = createBaseTeamBucket_TeamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExploitConfiguration(): ExploitConfiguration {
  return { entrypoint: "", isArchive: false, runEvery: undefined, timeout: undefined, disabled: false, endless: false };
}

export const ExploitConfiguration = {
  encode(message: ExploitConfiguration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entrypoint !== "") {
      writer.uint32(10).string(message.entrypoint);
    }
    if (message.isArchive === true) {
      writer.uint32(16).bool(message.isArchive);
    }
    if (message.runEvery !== undefined) {
      Duration.encode(message.runEvery, writer.uint32(26).fork()).ldelim();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(34).fork()).ldelim();
    }
    if (message.disabled === true) {
      writer.uint32(40).bool(message.disabled);
    }
    if (message.endless === true) {
      writer.uint32(48).bool(message.endless);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExploitConfiguration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entrypoint = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isArchive = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.runEvery = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.endless = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploitConfiguration {
    return {
      entrypoint: isSet(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      isArchive: isSet(object.isArchive) ? globalThis.Boolean(object.isArchive) : false,
      runEvery: isSet(object.runEvery) ? Duration.fromJSON(object.runEvery) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      endless: isSet(object.endless) ? globalThis.Boolean(object.endless) : false,
    };
  },

  toJSON(message: ExploitConfiguration): unknown {
    const obj: any = {};
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.isArchive === true) {
      obj.isArchive = message.isArchive;
    }
    if (message.runEvery !== undefined) {
      obj.runEvery = Duration.toJSON(message.runEvery);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.disabled === true) {
      obj.disabled = message.disabled;
    }
    if (message.endless === true) {
      obj.endless = message.endless;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExploitConfiguration>, I>>(base?: I): ExploitConfiguration {
    return ExploitConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExploitConfiguration>, I>>(object: I): ExploitConfiguration {
    const message = createBaseExploitConfiguration();
    message.entrypoint = object.entrypoint ?? "";
    message.isArchive = object.isArchive ?? false;
    message.runEvery = (object.runEvery !== undefined && object.runEvery !== null)
      ? Duration.fromPartial(object.runEvery)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.disabled = object.disabled ?? false;
    message.endless = object.endless ?? false;
    return message;
  },
};

function createBaseExploitState(): ExploitState {
  return { exploitId: "", version: Long.ZERO, file: undefined, config: undefined };
}

export const ExploitState = {
  encode(message: ExploitState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exploitId !== "") {
      writer.uint32(10).string(message.exploitId);
    }
    if (!message.version.isZero()) {
      writer.uint32(16).int64(message.version);
    }
    if (message.file !== undefined) {
      FileInfo.encode(message.file, writer.uint32(26).fork()).ldelim();
    }
    if (message.config !== undefined) {
      ExploitConfiguration.encode(message.config, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExploitState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploitState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exploitId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.file = FileInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.config = ExploitConfiguration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploitState {
    return {
      exploitId: isSet(object.exploitId) ? globalThis.String(object.exploitId) : "",
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
      file: isSet(object.file) ? FileInfo.fromJSON(object.file) : undefined,
      config: isSet(object.config) ? ExploitConfiguration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: ExploitState): unknown {
    const obj: any = {};
    if (message.exploitId !== "") {
      obj.exploitId = message.exploitId;
    }
    if (!message.version.isZero()) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    if (message.file !== undefined) {
      obj.file = FileInfo.toJSON(message.file);
    }
    if (message.config !== undefined) {
      obj.config = ExploitConfiguration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExploitState>, I>>(base?: I): ExploitState {
    return ExploitState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExploitState>, I>>(object: I): ExploitState {
    const message = createBaseExploitState();
    message.exploitId = object.exploitId ?? "";
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    message.file = (object.file !== undefined && object.file !== null) ? FileInfo.fromPartial(object.file) : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? ExploitConfiguration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseConfig(): Config {
  return { farmUrl: "", farmPassword: "", flagRegexp: "", pingEvery: undefined, submitEvery: undefined, environ: [] };
}

export const Config = {
  encode(message: Config, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.farmUrl !== "") {
      writer.uint32(10).string(message.farmUrl);
    }
    if (message.farmPassword !== "") {
      writer.uint32(18).string(message.farmPassword);
    }
    if (message.flagRegexp !== "") {
      writer.uint32(26).string(message.flagRegexp);
    }
    if (message.pingEvery !== undefined) {
      Duration.encode(message.pingEvery, writer.uint32(34).fork()).ldelim();
    }
    if (message.submitEvery !== undefined) {
      Duration.encode(message.submitEvery, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.environ) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Config {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.farmUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.farmPassword = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.flagRegexp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pingEvery = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.submitEvery = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.environ.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      farmUrl: isSet(object.farmUrl) ? globalThis.String(object.farmUrl) : "",
      farmPassword: isSet(object.farmPassword) ? globalThis.String(object.farmPassword) : "",
      flagRegexp: isSet(object.flagRegexp) ? globalThis.String(object.flagRegexp) : "",
      pingEvery: isSet(object.pingEvery) ? Duration.fromJSON(object.pingEvery) : undefined,
      submitEvery: isSet(object.submitEvery) ? Duration.fromJSON(object.submitEvery) : undefined,
      environ: globalThis.Array.isArray(object?.environ) ? object.environ.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.farmUrl !== "") {
      obj.farmUrl = message.farmUrl;
    }
    if (message.farmPassword !== "") {
      obj.farmPassword = message.farmPassword;
    }
    if (message.flagRegexp !== "") {
      obj.flagRegexp = message.flagRegexp;
    }
    if (message.pingEvery !== undefined) {
      obj.pingEvery = Duration.toJSON(message.pingEvery);
    }
    if (message.submitEvery !== undefined) {
      obj.submitEvery = Duration.toJSON(message.submitEvery);
    }
    if (message.environ?.length) {
      obj.environ = message.environ;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.farmUrl = object.farmUrl ?? "";
    message.farmPassword = object.farmPassword ?? "";
    message.flagRegexp = object.flagRegexp ?? "";
    message.pingEvery = (object.pingEvery !== undefined && object.pingEvery !== null)
      ? Duration.fromPartial(object.pingEvery)
      : undefined;
    message.submitEvery = (object.submitEvery !== undefined && object.submitEvery !== null)
      ? Duration.fromPartial(object.submitEvery)
      : undefined;
    message.environ = object.environ?.map((e) => e) || [];
    return message;
  },
};

function createBaseServerState(): ServerState {
  return { clientTeamMap: new Map(), exploits: [], config: undefined };
}

export const ServerState = {
  encode(message: ServerState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    message.clientTeamMap.forEach((value, key) => {
      ServerState_ClientTeamMapEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    for (const v of message.exploits) {
      ExploitState.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.config !== undefined) {
      Config.encode(message.config, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ServerState_ClientTeamMapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.clientTeamMap.set(entry1.key, entry1.value);
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exploits.push(ExploitState.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = Config.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerState {
    return {
      clientTeamMap: isObject(object.clientTeamMap)
        ? Object.entries(object.clientTeamMap).reduce<Map<string, TeamBucket>>((acc, [key, value]) => {
          acc.set(key, TeamBucket.fromJSON(value));
          return acc;
        }, new Map())
        : new Map(),
      exploits: globalThis.Array.isArray(object?.exploits)
        ? object.exploits.map((e: any) => ExploitState.fromJSON(e))
        : [],
      config: isSet(object.config) ? Config.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: ServerState): unknown {
    const obj: any = {};
    if (message.clientTeamMap?.size) {
      obj.clientTeamMap = {};
      message.clientTeamMap.forEach((v, k) => {
        obj.clientTeamMap[k] = TeamBucket.toJSON(v);
      });
    }
    if (message.exploits?.length) {
      obj.exploits = message.exploits.map((e) => ExploitState.toJSON(e));
    }
    if (message.config !== undefined) {
      obj.config = Config.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerState>, I>>(base?: I): ServerState {
    return ServerState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerState>, I>>(object: I): ServerState {
    const message = createBaseServerState();
    message.clientTeamMap = (() => {
      const m = new Map();
      (object.clientTeamMap as Map<string, TeamBucket> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, TeamBucket.fromPartial(value));
        }
      });
      return m;
    })();
    message.exploits = object.exploits?.map((e) => ExploitState.fromPartial(e)) || [];
    message.config = (object.config !== undefined && object.config !== null)
      ? Config.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseServerState_ClientTeamMapEntry(): ServerState_ClientTeamMapEntry {
  return { key: "", value: undefined };
}

export const ServerState_ClientTeamMapEntry = {
  encode(message: ServerState_ClientTeamMapEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TeamBucket.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerState_ClientTeamMapEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerState_ClientTeamMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TeamBucket.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerState_ClientTeamMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TeamBucket.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ServerState_ClientTeamMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TeamBucket.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerState_ClientTeamMapEntry>, I>>(base?: I): ServerState_ClientTeamMapEntry {
    return ServerState_ClientTeamMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerState_ClientTeamMapEntry>, I>>(
    object: I,
  ): ServerState_ClientTeamMapEntry {
    const message = createBaseServerState_ClientTeamMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TeamBucket.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePingRequest(): PingRequest {
  return { clientId: "", payload: undefined };
}

export const PingRequest = {
  encode(message: PingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    switch (message.payload?.$case) {
      case "serverInfoRequest":
        PingRequest_ServerInfo.encode(message.payload.serverInfoRequest, writer.uint32(18).fork()).ldelim();
        break;
      case "heartbeatRequest":
        PingRequest_Heartbeat.encode(message.payload.heartbeatRequest, writer.uint32(26).fork()).ldelim();
        break;
      case "leaveRequest":
        PingRequest_Leave.encode(message.payload.leaveRequest, writer.uint32(34).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = {
            $case: "serverInfoRequest",
            serverInfoRequest: PingRequest_ServerInfo.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = {
            $case: "heartbeatRequest",
            heartbeatRequest: PingRequest_Heartbeat.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payload = { $case: "leaveRequest", leaveRequest: PingRequest_Leave.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      payload: isSet(object.serverInfoRequest)
        ? { $case: "serverInfoRequest", serverInfoRequest: PingRequest_ServerInfo.fromJSON(object.serverInfoRequest) }
        : isSet(object.heartbeatRequest)
        ? { $case: "heartbeatRequest", heartbeatRequest: PingRequest_Heartbeat.fromJSON(object.heartbeatRequest) }
        : isSet(object.leaveRequest)
        ? { $case: "leaveRequest", leaveRequest: PingRequest_Leave.fromJSON(object.leaveRequest) }
        : undefined,
    };
  },

  toJSON(message: PingRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.payload?.$case === "serverInfoRequest") {
      obj.serverInfoRequest = PingRequest_ServerInfo.toJSON(message.payload.serverInfoRequest);
    }
    if (message.payload?.$case === "heartbeatRequest") {
      obj.heartbeatRequest = PingRequest_Heartbeat.toJSON(message.payload.heartbeatRequest);
    }
    if (message.payload?.$case === "leaveRequest") {
      obj.leaveRequest = PingRequest_Leave.toJSON(message.payload.leaveRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingRequest>, I>>(base?: I): PingRequest {
    return PingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingRequest>, I>>(object: I): PingRequest {
    const message = createBasePingRequest();
    message.clientId = object.clientId ?? "";
    if (
      object.payload?.$case === "serverInfoRequest" &&
      object.payload?.serverInfoRequest !== undefined &&
      object.payload?.serverInfoRequest !== null
    ) {
      message.payload = {
        $case: "serverInfoRequest",
        serverInfoRequest: PingRequest_ServerInfo.fromPartial(object.payload.serverInfoRequest),
      };
    }
    if (
      object.payload?.$case === "heartbeatRequest" &&
      object.payload?.heartbeatRequest !== undefined &&
      object.payload?.heartbeatRequest !== null
    ) {
      message.payload = {
        $case: "heartbeatRequest",
        heartbeatRequest: PingRequest_Heartbeat.fromPartial(object.payload.heartbeatRequest),
      };
    }
    if (
      object.payload?.$case === "leaveRequest" &&
      object.payload?.leaveRequest !== undefined &&
      object.payload?.leaveRequest !== null
    ) {
      message.payload = {
        $case: "leaveRequest",
        leaveRequest: PingRequest_Leave.fromPartial(object.payload.leaveRequest),
      };
    }
    return message;
  },
};

function createBasePingRequest_ServerInfo(): PingRequest_ServerInfo {
  return {};
}

export const PingRequest_ServerInfo = {
  encode(_: PingRequest_ServerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingRequest_ServerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest_ServerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingRequest_ServerInfo {
    return {};
  },

  toJSON(_: PingRequest_ServerInfo): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PingRequest_ServerInfo>, I>>(base?: I): PingRequest_ServerInfo {
    return PingRequest_ServerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingRequest_ServerInfo>, I>>(_: I): PingRequest_ServerInfo {
    const message = createBasePingRequest_ServerInfo();
    return message;
  },
};

function createBasePingRequest_Heartbeat(): PingRequest_Heartbeat {
  return { weight: 0 };
}

export const PingRequest_Heartbeat = {
  encode(message: PingRequest_Heartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.weight !== 0) {
      writer.uint32(8).int32(message.weight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingRequest_Heartbeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest_Heartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weight = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingRequest_Heartbeat {
    return { weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0 };
  },

  toJSON(message: PingRequest_Heartbeat): unknown {
    const obj: any = {};
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingRequest_Heartbeat>, I>>(base?: I): PingRequest_Heartbeat {
    return PingRequest_Heartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingRequest_Heartbeat>, I>>(object: I): PingRequest_Heartbeat {
    const message = createBasePingRequest_Heartbeat();
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBasePingRequest_Leave(): PingRequest_Leave {
  return {};
}

export const PingRequest_Leave = {
  encode(_: PingRequest_Leave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingRequest_Leave {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest_Leave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingRequest_Leave {
    return {};
  },

  toJSON(_: PingRequest_Leave): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PingRequest_Leave>, I>>(base?: I): PingRequest_Leave {
    return PingRequest_Leave.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingRequest_Leave>, I>>(_: I): PingRequest_Leave {
    const message = createBasePingRequest_Leave();
    return message;
  },
};

function createBasePingResponse(): PingResponse {
  return { state: undefined };
}

export const PingResponse = {
  encode(message: PingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      ServerState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = ServerState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingResponse {
    return { state: isSet(object.state) ? ServerState.fromJSON(object.state) : undefined };
  },

  toJSON(message: PingResponse): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = ServerState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingResponse>, I>>(base?: I): PingResponse {
    return PingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingResponse>, I>>(object: I): PingResponse {
    const message = createBasePingResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? ServerState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseExploitRequest(): ExploitRequest {
  return { exploitId: "" };
}

export const ExploitRequest = {
  encode(message: ExploitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exploitId !== "") {
      writer.uint32(10).string(message.exploitId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExploitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exploitId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploitRequest {
    return { exploitId: isSet(object.exploitId) ? globalThis.String(object.exploitId) : "" };
  },

  toJSON(message: ExploitRequest): unknown {
    const obj: any = {};
    if (message.exploitId !== "") {
      obj.exploitId = message.exploitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExploitRequest>, I>>(base?: I): ExploitRequest {
    return ExploitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExploitRequest>, I>>(object: I): ExploitRequest {
    const message = createBaseExploitRequest();
    message.exploitId = object.exploitId ?? "";
    return message;
  },
};

function createBaseExploitResponse(): ExploitResponse {
  return { state: undefined };
}

export const ExploitResponse = {
  encode(message: ExploitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      ExploitState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExploitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExploitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = ExploitState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExploitResponse {
    return { state: isSet(object.state) ? ExploitState.fromJSON(object.state) : undefined };
  },

  toJSON(message: ExploitResponse): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = ExploitState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExploitResponse>, I>>(base?: I): ExploitResponse {
    return ExploitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExploitResponse>, I>>(object: I): ExploitResponse {
    const message = createBaseExploitResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? ExploitState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseUpdateExploitRequest(): UpdateExploitRequest {
  return { state: undefined };
}

export const UpdateExploitRequest = {
  encode(message: UpdateExploitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      ExploitState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateExploitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExploitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = ExploitState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateExploitRequest {
    return { state: isSet(object.state) ? ExploitState.fromJSON(object.state) : undefined };
  },

  toJSON(message: UpdateExploitRequest): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = ExploitState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateExploitRequest>, I>>(base?: I): UpdateExploitRequest {
    return UpdateExploitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateExploitRequest>, I>>(object: I): UpdateExploitRequest {
    const message = createBaseUpdateExploitRequest();
    message.state = (object.state !== undefined && object.state !== null)
      ? ExploitState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseUpdateExploitResponse(): UpdateExploitResponse {
  return { state: undefined };
}

export const UpdateExploitResponse = {
  encode(message: UpdateExploitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      ExploitState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateExploitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExploitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = ExploitState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateExploitResponse {
    return { state: isSet(object.state) ? ExploitState.fromJSON(object.state) : undefined };
  },

  toJSON(message: UpdateExploitResponse): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = ExploitState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateExploitResponse>, I>>(base?: I): UpdateExploitResponse {
    return UpdateExploitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateExploitResponse>, I>>(object: I): UpdateExploitResponse {
    const message = createBaseUpdateExploitResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? ExploitState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseBroadcastRequest(): BroadcastRequest {
  return { command: "" };
}

export const BroadcastRequest = {
  encode(message: BroadcastRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastRequest {
    return { command: isSet(object.command) ? globalThis.String(object.command) : "" };
  },

  toJSON(message: BroadcastRequest): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastRequest>, I>>(base?: I): BroadcastRequest {
    return BroadcastRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastRequest>, I>>(object: I): BroadcastRequest {
    const message = createBaseBroadcastRequest();
    message.command = object.command ?? "";
    return message;
  },
};

function createBaseBroadcastResponse(): BroadcastResponse {
  return {};
}

export const BroadcastResponse = {
  encode(_: BroadcastResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BroadcastResponse {
    return {};
  },

  toJSON(_: BroadcastResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastResponse>, I>>(base?: I): BroadcastResponse {
    return BroadcastResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastResponse>, I>>(_: I): BroadcastResponse {
    const message = createBaseBroadcastResponse();
    return message;
  },
};

function createBaseBroadcastSubscribeRequest(): BroadcastSubscribeRequest {
  return {};
}

export const BroadcastSubscribeRequest = {
  encode(_: BroadcastSubscribeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastSubscribeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BroadcastSubscribeRequest {
    return {};
  },

  toJSON(_: BroadcastSubscribeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastSubscribeRequest>, I>>(base?: I): BroadcastSubscribeRequest {
    return BroadcastSubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastSubscribeRequest>, I>>(_: I): BroadcastSubscribeRequest {
    const message = createBaseBroadcastSubscribeRequest();
    return message;
  },
};

function createBaseBroadcastSubscribeResponse(): BroadcastSubscribeResponse {
  return { command: "" };
}

export const BroadcastSubscribeResponse = {
  encode(message: BroadcastSubscribeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastSubscribeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastSubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastSubscribeResponse {
    return { command: isSet(object.command) ? globalThis.String(object.command) : "" };
  },

  toJSON(message: BroadcastSubscribeResponse): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastSubscribeResponse>, I>>(base?: I): BroadcastSubscribeResponse {
    return BroadcastSubscribeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastSubscribeResponse>, I>>(object: I): BroadcastSubscribeResponse {
    const message = createBaseBroadcastSubscribeResponse();
    message.command = object.command ?? "";
    return message;
  },
};

function createBaseSingleRunRequest(): SingleRunRequest {
  return { exploitId: "" };
}

export const SingleRunRequest = {
  encode(message: SingleRunRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exploitId !== "") {
      writer.uint32(10).string(message.exploitId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleRunRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exploitId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleRunRequest {
    return { exploitId: isSet(object.exploitId) ? globalThis.String(object.exploitId) : "" };
  },

  toJSON(message: SingleRunRequest): unknown {
    const obj: any = {};
    if (message.exploitId !== "") {
      obj.exploitId = message.exploitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleRunRequest>, I>>(base?: I): SingleRunRequest {
    return SingleRunRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleRunRequest>, I>>(object: I): SingleRunRequest {
    const message = createBaseSingleRunRequest();
    message.exploitId = object.exploitId ?? "";
    return message;
  },
};

function createBaseSingleRunResponse(): SingleRunResponse {
  return {};
}

export const SingleRunResponse = {
  encode(_: SingleRunResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleRunResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SingleRunResponse {
    return {};
  },

  toJSON(_: SingleRunResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleRunResponse>, I>>(base?: I): SingleRunResponse {
    return SingleRunResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleRunResponse>, I>>(_: I): SingleRunResponse {
    const message = createBaseSingleRunResponse();
    return message;
  },
};

function createBaseSingleRunSubscribeRequest(): SingleRunSubscribeRequest {
  return {};
}

export const SingleRunSubscribeRequest = {
  encode(_: SingleRunSubscribeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleRunSubscribeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleRunSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SingleRunSubscribeRequest {
    return {};
  },

  toJSON(_: SingleRunSubscribeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleRunSubscribeRequest>, I>>(base?: I): SingleRunSubscribeRequest {
    return SingleRunSubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleRunSubscribeRequest>, I>>(_: I): SingleRunSubscribeRequest {
    const message = createBaseSingleRunSubscribeRequest();
    return message;
  },
};

function createBaseSingleRunSubscribeResponse(): SingleRunSubscribeResponse {
  return { exploitId: "" };
}

export const SingleRunSubscribeResponse = {
  encode(message: SingleRunSubscribeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exploitId !== "") {
      writer.uint32(10).string(message.exploitId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleRunSubscribeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleRunSubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exploitId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleRunSubscribeResponse {
    return { exploitId: isSet(object.exploitId) ? globalThis.String(object.exploitId) : "" };
  },

  toJSON(message: SingleRunSubscribeResponse): unknown {
    const obj: any = {};
    if (message.exploitId !== "") {
      obj.exploitId = message.exploitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SingleRunSubscribeResponse>, I>>(base?: I): SingleRunSubscribeResponse {
    return SingleRunSubscribeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SingleRunSubscribeResponse>, I>>(object: I): SingleRunSubscribeResponse {
    const message = createBaseSingleRunSubscribeResponse();
    message.exploitId = object.exploitId ?? "";
    return message;
  },
};

export type ServiceDefinition = typeof ServiceDefinition;
export const ServiceDefinition = {
  name: "Service",
  fullName: "exploits.Service",
  methods: {
    ping: {
      name: "Ping",
      requestType: PingRequest,
      requestStream: false,
      responseType: PingResponse,
      responseStream: false,
      options: {},
    },
    exploit: {
      name: "Exploit",
      requestType: ExploitRequest,
      requestStream: false,
      responseType: ExploitResponse,
      responseStream: false,
      options: {},
    },
    updateExploit: {
      name: "UpdateExploit",
      requestType: UpdateExploitRequest,
      requestStream: false,
      responseType: UpdateExploitResponse,
      responseStream: false,
      options: {},
    },
    broadcastCommand: {
      name: "BroadcastCommand",
      requestType: BroadcastRequest,
      requestStream: false,
      responseType: BroadcastResponse,
      responseStream: false,
      options: {},
    },
    broadcastSubscribe: {
      name: "BroadcastSubscribe",
      requestType: BroadcastSubscribeRequest,
      requestStream: false,
      responseType: BroadcastSubscribeResponse,
      responseStream: true,
      options: {},
    },
    singleRun: {
      name: "SingleRun",
      requestType: SingleRunRequest,
      requestStream: false,
      responseType: SingleRunResponse,
      responseStream: false,
      options: {},
    },
    singleRunSubscribe: {
      name: "SingleRunSubscribe",
      requestType: SingleRunSubscribeRequest,
      requestStream: false,
      responseType: SingleRunSubscribeResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface ServiceImplementation<CallContextExt = {}> {
  ping(request: PingRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PingResponse>>;
  exploit(request: ExploitRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ExploitResponse>>;
  updateExploit(
    request: UpdateExploitRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UpdateExploitResponse>>;
  broadcastCommand(
    request: BroadcastRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BroadcastResponse>>;
  broadcastSubscribe(
    request: BroadcastSubscribeRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<BroadcastSubscribeResponse>>;
  singleRun(request: SingleRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SingleRunResponse>>;
  singleRunSubscribe(
    request: SingleRunSubscribeRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SingleRunSubscribeResponse>>;
}

export interface ServiceClient<CallOptionsExt = {}> {
  ping(request: DeepPartial<PingRequest>, options?: CallOptions & CallOptionsExt): Promise<PingResponse>;
  exploit(request: DeepPartial<ExploitRequest>, options?: CallOptions & CallOptionsExt): Promise<ExploitResponse>;
  updateExploit(
    request: DeepPartial<UpdateExploitRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpdateExploitResponse>;
  broadcastCommand(
    request: DeepPartial<BroadcastRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BroadcastResponse>;
  broadcastSubscribe(
    request: DeepPartial<BroadcastSubscribeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<BroadcastSubscribeResponse>;
  singleRun(request: DeepPartial<SingleRunRequest>, options?: CallOptions & CallOptionsExt): Promise<SingleRunResponse>;
  singleRunSubscribe(
    request: DeepPartial<SingleRunSubscribeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SingleRunSubscribeResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };
